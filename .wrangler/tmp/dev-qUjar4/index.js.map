{
  "version": 3,
  "sources": ["../../../workers/auth.ts", "../../../workers/cache.ts", "../../../workers/index.ts", "../../../../../../.nvm/versions/node/v22.12.0/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../../.nvm/versions/node/v22.12.0/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-B2uX3S/middleware-insertion-facade.js", "../../../../../../.nvm/versions/node/v22.12.0/lib/node_modules/wrangler/templates/middleware/common.ts", "../bundle-B2uX3S/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/benjiemalinao/Documents/WORKING PROTOTYPE/Voice AI Performance & Config Dashboard/.wrangler/tmp/dev-qUjar4",
  "sourcesContent": ["// Authentication utilities for Cloudflare Workers\n\n/**\n * Generate a random ID\n */\nexport function generateId(): string {\n  return crypto.randomUUID();\n}\n\n/**\n * Hash a password using SHA-256\n */\nexport async function hashPassword(password: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(password);\n  const hash = await crypto.subtle.digest('SHA-256', data);\n  return Array.from(new Uint8Array(hash))\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Verify a password against a hash\n */\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  const passwordHash = await hashPassword(password);\n  return passwordHash === hash;\n}\n\n/**\n * Generate a JWT token (simplified - no external libraries)\n * Format: header.payload.signature (base64url encoded)\n */\nexport async function generateToken(userId: string, secret: string): Promise<string> {\n  const header = {\n    alg: 'HS256',\n    typ: 'JWT'\n  };\n\n  const payload = {\n    userId,\n    iat: Math.floor(Date.now() / 1000),\n    exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60) // 7 days\n  };\n\n  const encodedHeader = btoa(JSON.stringify(header));\n  const encodedPayload = btoa(JSON.stringify(payload));\n  const data = `${encodedHeader}.${encodedPayload}`;\n\n  // Sign with HMAC SHA-256\n  const encoder = new TextEncoder();\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign']\n  );\n\n  const signature = await crypto.subtle.sign(\n    'HMAC',\n    key,\n    encoder.encode(data)\n  );\n\n  const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)));\n  return `${data}.${encodedSignature}`;\n}\n\n/**\n * Verify and decode a JWT token\n */\nexport async function verifyToken(token: string, secret: string): Promise<{ userId: string } | null> {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) return null;\n\n    const [encodedHeader, encodedPayload, encodedSignature] = parts;\n    const data = `${encodedHeader}.${encodedPayload}`;\n\n    // Verify signature\n    const encoder = new TextEncoder();\n    const key = await crypto.subtle.importKey(\n      'raw',\n      encoder.encode(secret),\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['verify']\n    );\n\n    const signature = Uint8Array.from(atob(encodedSignature), c => c.charCodeAt(0));\n    const valid = await crypto.subtle.verify(\n      'HMAC',\n      key,\n      signature,\n      encoder.encode(data)\n    );\n\n    if (!valid) return null;\n\n    // Decode payload\n    const payload = JSON.parse(atob(encodedPayload));\n\n    // Check expiration\n    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\n      return null;\n    }\n\n    return { userId: payload.userId };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Encrypt data using AES-GCM\n */\nexport async function encrypt(text: string, password: string, salt: string): Promise<string> {\n  const encoder = new TextEncoder();\n  \n  // Derive key from password using PBKDF2\n  const keyMaterial = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(password),\n    'PBKDF2',\n    false,\n    ['deriveBits', 'deriveKey']\n  );\n\n  const key = await crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt: encoder.encode(salt),\n      iterations: 100000,\n      hash: 'SHA-256'\n    },\n    keyMaterial,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['encrypt']\n  );\n\n  // Generate random IV\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n\n  // Encrypt\n  const encrypted = await crypto.subtle.encrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    encoder.encode(text)\n  );\n\n  // Combine IV and encrypted data\n  const combined = new Uint8Array(iv.length + encrypted.byteLength);\n  combined.set(iv);\n  combined.set(new Uint8Array(encrypted), iv.length);\n\n  // Return as base64\n  return btoa(String.fromCharCode(...combined));\n}\n\n/**\n * Decrypt data using AES-GCM\n */\nexport async function decrypt(encryptedText: string, password: string, salt: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n\n  // Decode from base64\n  const combined = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));\n\n  // Extract IV and encrypted data\n  const iv = combined.slice(0, 12);\n  const encrypted = combined.slice(12);\n\n  // Derive key from password\n  const keyMaterial = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(password),\n    'PBKDF2',\n    false,\n    ['deriveBits', 'deriveKey']\n  );\n\n  const key = await crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt: encoder.encode(salt),\n      iterations: 100000,\n      hash: 'SHA-256'\n    },\n    keyMaterial,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['decrypt']\n  );\n\n  // Decrypt\n  const decrypted = await crypto.subtle.decrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    encrypted\n  );\n\n  return decoder.decode(decrypted);\n}\n\n/**\n * Generate a random salt for encryption\n */\nexport function generateSalt(): string {\n  const array = new Uint8Array(16);\n  crypto.getRandomValues(array);\n  return Array.from(array)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Generate a secure temporary password\n * Format: 3 random words + 2 digits + 1 special char\n * Example: \"Cloud-Secure-Voice-42!\"\n */\nexport function generateTemporaryPassword(): string {\n  const words = [\n    'Cloud', 'Secure', 'Voice', 'Team', 'Digital', 'Smart', 'Quick', 'Bright',\n    'Swift', 'Prime', 'Elite', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Omega',\n    'Nexus', 'Quantum', 'Stellar', 'Cosmic', 'Cyber', 'Pixel', 'Matrix', 'Vertex'\n  ];\n\n  const specialChars = '!@#$%^&*';\n\n  // Pick 3 random words\n  const word1 = words[Math.floor(Math.random() * words.length)];\n  const word2 = words[Math.floor(Math.random() * words.length)];\n  const word3 = words[Math.floor(Math.random() * words.length)];\n\n  // Generate 2 random digits\n  const digits = Math.floor(Math.random() * 100).toString().padStart(2, '0');\n\n  // Pick 1 special character\n  const special = specialChars[Math.floor(Math.random() * specialChars.length)];\n\n  return `${word1}-${word2}-${word3}-${digits}${special}`;\n}\n\n", "/**\n * KV Cache Service for Voice AI Dashboard\n * Provides intelligent caching for recordings and intent analysis data\n */\n\nexport interface CacheOptions {\n  ttl?: number; // Time to live in seconds\n  tags?: string[]; // Tags for cache invalidation\n}\n\nexport interface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n  tags?: string[];\n}\n\nexport class VoiceAICache {\n  private kv: KVNamespace;\n  private defaultTTL: number;\n\n  constructor(kv: KVNamespace, defaultTTL: number = 300) {\n    this.kv = kv;\n    this.defaultTTL = defaultTTL;\n  }\n\n  /**\n   * Generate cache key for recordings page\n   */\n  private getRecordingsKey(userId: string, page: number = 1, limit: number = 50): string {\n    return `recordings:user:${userId}:page:${page}:limit:${limit}`;\n  }\n\n  /**\n   * Generate cache key for individual call details\n   */\n  private getCallKey(userId: string, callId: string): string {\n    return `recordings:user:${userId}:call:${callId}`;\n  }\n\n  /**\n   * Generate cache key for intent analysis\n   */\n  private getIntentKey(userId: string, callId: string): string {\n    return `intent:user:${userId}:analysis:${callId}`;\n  }\n\n  /**\n   * Generate cache key for intent dashboard summary\n   */\n  private getIntentSummaryKey(userId: string): string {\n    return `intent:user:${userId}:summary`;\n  }\n\n  /**\n   * Generate cache key for enhanced data\n   */\n  private getEnhancedDataKey(userId: string, callId: string): string {\n    return `enhanced:user:${userId}:call:${callId}`;\n  }\n\n  /**\n   * Get data from cache\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      const cached = await this.kv.get(key, 'json') as CacheEntry<T> | null;\n      \n      if (!cached) {\n        return null;\n      }\n\n      // Check if expired\n      const now = Math.floor(Date.now() / 1000);\n      if (cached.timestamp + cached.ttl < now) {\n        // Expired, delete and return null\n        await this.kv.delete(key);\n        return null;\n      }\n\n      return cached.data;\n    } catch (error) {\n      console.error('Cache get error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Set data in cache\n   */\n  async set<T>(key: string, data: T, options: CacheOptions = {}): Promise<void> {\n    try {\n      const ttl = options.ttl || this.defaultTTL;\n      const entry: CacheEntry<T> = {\n        data,\n        timestamp: Math.floor(Date.now() / 1000),\n        ttl,\n        tags: options.tags\n      };\n\n      await this.kv.put(key, JSON.stringify(entry), {\n        expirationTtl: ttl\n      });\n    } catch (error) {\n      console.error('Cache set error:', error);\n    }\n  }\n\n  /**\n   * Delete data from cache\n   */\n  async delete(key: string): Promise<void> {\n    try {\n      await this.kv.delete(key);\n    } catch (error) {\n      console.error('Cache delete error:', error);\n    }\n  }\n\n  /**\n   * Invalidate cache by pattern (for user-specific data)\n   */\n  async invalidateUserCache(userId: string): Promise<void> {\n    try {\n      // List all keys for this user\n      const list = await this.kv.list({ prefix: `recordings:user:${userId}:` });\n      const intentList = await this.kv.list({ prefix: `intent:user:${userId}:` });\n      const enhancedList = await this.kv.list({ prefix: `enhanced:user:${userId}:` });\n\n      // Delete all user-related cache entries\n      const keysToDelete = [\n        ...list.keys.map(k => k.name),\n        ...intentList.keys.map(k => k.name),\n        ...enhancedList.keys.map(k => k.name)\n      ];\n\n      await Promise.all(keysToDelete.map(key => this.kv.delete(key)));\n    } catch (error) {\n      console.error('Cache invalidation error:', error);\n    }\n  }\n\n  /**\n   * Cache recordings page data\n   */\n  async cacheRecordings(\n    userId: string, \n    recordings: any[], \n    page: number = 1, \n    limit: number = 50,\n    ttl: number = 300 // 5 minutes\n  ): Promise<void> {\n    const key = this.getRecordingsKey(userId, page, limit);\n    await this.set(key, recordings, { ttl });\n  }\n\n  /**\n   * Get cached recordings page data\n   */\n  async getCachedRecordings(userId: string, page: number = 1, limit: number = 50): Promise<any[] | null> {\n    const key = this.getRecordingsKey(userId, page, limit);\n    return await this.get<any[]>(key);\n  }\n\n  /**\n   * Cache individual call details\n   */\n  async cacheCall(userId: string, callId: string, callData: any, ttl: number = 600): Promise<void> {\n    const key = this.getCallKey(userId, callId);\n    await this.set(key, callData, { ttl });\n  }\n\n  /**\n   * Get cached call details\n   */\n  async getCachedCall(userId: string, callId: string): Promise<any | null> {\n    const key = this.getCallKey(userId, callId);\n    return await this.get<any>(key);\n  }\n\n  /**\n   * Cache intent analysis data\n   */\n  async cacheIntentAnalysis(userId: string, callId: string, intentData: any, ttl: number = 600): Promise<void> {\n    const key = this.getIntentKey(userId, callId);\n    await this.set(key, intentData, { ttl });\n  }\n\n  /**\n   * Get cached intent analysis\n   */\n  async getCachedIntentAnalysis(userId: string, callId: string): Promise<any | null> {\n    const key = this.getIntentKey(userId, callId);\n    return await this.get<any>(key);\n  }\n\n  /**\n   * Cache intent dashboard summary\n   */\n  async cacheIntentSummary(userId: string, summaryData: any, ttl: number = 120): Promise<void> {\n    const key = this.getIntentSummaryKey(userId);\n    await this.set(key, summaryData, { ttl });\n  }\n\n  /**\n   * Get cached intent summary\n   */\n  async getCachedIntentSummary(userId: string): Promise<any | null> {\n    const key = this.getIntentSummaryKey(userId);\n    return await this.get<any>(key);\n  }\n\n  /**\n   * Cache enhanced data\n   */\n  async cacheEnhancedData(userId: string, callId: string, enhancedData: any, ttl: number = 1800): Promise<void> {\n    const key = this.getEnhancedDataKey(userId, callId);\n    await this.set(key, enhancedData, { ttl });\n  }\n\n  /**\n   * Get cached enhanced data\n   */\n  async getCachedEnhancedData(userId: string, callId: string): Promise<any | null> {\n    const key = this.getEnhancedDataKey(userId, callId);\n    return await this.get<any>(key);\n  }\n\n  /**\n   * Invalidate specific call cache\n   */\n  async invalidateCallCache(userId: string, callId: string): Promise<void> {\n    await Promise.all([\n      this.delete(this.getCallKey(userId, callId)),\n      this.delete(this.getIntentKey(userId, callId)),\n      this.delete(this.getEnhancedDataKey(userId, callId))\n    ]);\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getCacheStats(): Promise<{\n    totalKeys: number;\n    recordingsKeys: number;\n    intentKeys: number;\n    enhancedKeys: number;\n  }> {\n    try {\n      const recordingsList = await this.kv.list({ prefix: 'recordings:' });\n      const intentList = await this.kv.list({ prefix: 'intent:' });\n      const enhancedList = await this.kv.list({ prefix: 'enhanced:' });\n\n      return {\n        totalKeys: recordingsList.keys.length + intentList.keys.length + enhancedList.keys.length,\n        recordingsKeys: recordingsList.keys.length,\n        intentKeys: intentList.keys.length,\n        enhancedKeys: enhancedList.keys.length\n      };\n    } catch (error) {\n      console.error('Cache stats error:', error);\n      return {\n        totalKeys: 0,\n        recordingsKeys: 0,\n        intentKeys: 0,\n        enhancedKeys: 0\n      };\n    }\n  }\n}\n\n/**\n * Cache TTL constants\n */\nexport const CACHE_TTL = {\n  RECORDINGS: 300,      // 5 minutes\n  CALL_DETAILS: 600,    // 10 minutes\n  INTENT_ANALYSIS: 600, // 10 minutes\n  INTENT_SUMMARY: 120,  // 2 minutes\n  ENHANCED_DATA: 1800,  // 30 minutes\n} as const;\n", "/**\n * Cloudflare Worker API for Voice AI Dashboard\n * Provides D1 database access and authentication\n */\n\nimport {\n  generateId,\n  hashPassword,\n  verifyPassword,\n  generateToken,\n  verifyToken,\n  encrypt,\n  decrypt,\n  generateSalt,\n  generateTemporaryPassword\n} from './auth';\nimport { VoiceAICache, CACHE_TTL } from './cache';\n\n// Cloudflare Worker types\ninterface D1Database {\n  prepare(query: string): D1PreparedStatement;\n}\n\ninterface D1PreparedStatement {\n  bind(...values: any[]): D1PreparedStatement;\n  all(): Promise<D1Result>;\n  first(): Promise<any>;\n  run(): Promise<D1Result>;\n}\n\ninterface D1Result {\n  results: any[];\n  success: boolean;\n  meta: any;\n}\n\ninterface KVNamespace {\n  get(key: string, type?: 'text' | 'json' | 'arrayBuffer' | 'stream'): Promise<any>;\n  put(key: string, value: string, options?: { expirationTtl?: number }): Promise<void>;\n  delete(key: string): Promise<void>;\n  list(options?: { prefix?: string }): Promise<{ keys: Array<{ name: string }> }>;\n}\n\ninterface ExecutionContext {\n  waitUntil(promise: Promise<any>): void;\n}\n\nexport interface Env {\n  DB: D1Database;\n  CACHE: KVNamespace;\n  JWT_SECRET: string; // Set this in wrangler.toml as a secret\n}\n\n// CORS headers\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, PATCH, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n};\n\n// Helper: JSON response with CORS\nfunction jsonResponse(data: any, status = 200) {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      ...corsHeaders,\n    },\n  });\n}\n\n// Helper: Get current timestamp\nfunction now(): number {\n  return Math.floor(Date.now() / 1000);\n}\n\n// Helper: Analyze call with OpenAI\ninterface CallAnalysisResult {\n  intent: string;\n  sentiment: string;\n  outcome: string;\n  customer_name?: string;\n  customer_email?: string;\n  appointment_date?: string;\n  appointment_time?: string;\n  appointment_type?: string;\n  appointment_notes?: string;\n}\n\nasync function analyzeCallWithOpenAI(\n  summary: string,\n  transcript: string,\n  openaiApiKey: string\n): Promise<CallAnalysisResult | null> {\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${openaiApiKey}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini',\n        messages: [\n          {\n            role: 'system',\n            content: `You are an AI that analyzes customer service call recordings. Analyze the call and respond with a JSON object containing:\n\nREQUIRED FIELDS:\n- intent: The customer's primary intent (e.g., \"Scheduling\", \"Information\", \"Complaint\", \"Purchase\", \"Support\")\n- sentiment: The overall sentiment of the call (\"Positive\", \"Neutral\", or \"Negative\")\n- outcome: The call outcome (\"Successful\", \"Unsuccessful\", \"Follow-up Required\", \"Abandoned\")\n\nOPTIONAL FIELDS (extract if mentioned in the call):\n- customer_name: The customer's full name (if mentioned)\n- customer_email: The customer's email address (if mentioned)\n\nAPPOINTMENT FIELDS (ONLY if intent is \"Scheduling\" and appointment was successfully booked):\n- appointment_date: The appointment date in ISO format (YYYY-MM-DD). Extract from phrases like \"tomorrow\", \"next Monday\", \"January 15th\", etc.\n- appointment_time: The appointment time in 12-hour format (e.g., \"2:00 PM\", \"10:30 AM\")\n- appointment_type: Type of appointment (e.g., \"Consultation\", \"Service Call\", \"Follow-up\", \"Installation\")\n- appointment_notes: Any special notes about the appointment (e.g., \"Bring ID\", \"Gate code: 1234\")\n\nIMPORTANT: Only include appointment fields if an appointment was ACTUALLY SCHEDULED. If the customer just inquired about scheduling but didn't book, do NOT include appointment fields.\n\nOnly respond with the JSON object, no additional text.`\n          },\n          {\n            role: 'user',\n            content: `Call Summary: ${summary}\\n\\nFull Transcript:\\n${transcript}`\n          }\n        ],\n        temperature: 0.3,\n        response_format: { type: 'json_object' }\n      })\n    });\n\n    if (!response.ok) {\n      console.error('OpenAI API error:', await response.text());\n      return null;\n    }\n\n    const data = await response.json() as any;\n    const result = JSON.parse(data.choices[0].message.content);\n\n    return {\n      intent: result.intent || 'Unknown',\n      sentiment: result.sentiment || 'Neutral',\n      outcome: result.outcome || 'Unknown',\n      customer_name: result.customer_name || null,\n      customer_email: result.customer_email || null,\n      appointment_date: result.appointment_date || null,\n      appointment_time: result.appointment_time || null,\n      appointment_type: result.appointment_type || null,\n      appointment_notes: result.appointment_notes || null\n    };\n  } catch (error) {\n    console.error('Error analyzing call with OpenAI:', error);\n    return null;\n  }\n}\n\n// Helper: Extract keywords from transcript\nfunction extractKeywords(transcript: string): string[] {\n  if (!transcript || transcript.trim().length === 0) {\n    return [];\n  }\n\n  // Common stop words to filter out\n  const stopWords = new Set([\n    'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your', 'yours',\n    'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', 'her', 'hers',\n    'herself', 'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',\n    'what', 'which', 'who', 'whom', 'this', 'that', 'these', 'those', 'am', 'is', 'are',\n    'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does',\n    'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until',\n    'while', 'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into',\n    'through', 'during', 'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down',\n    'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here',\n    'there', 'when', 'where', 'why', 'how', 'all', 'both', 'each', 'few', 'more', 'most',\n    'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than',\n    'too', 'very', 's', 't', 'can', 'will', 'just', 'don', 'should', 'now', 'yeah',\n    'yes', 'okay', 'ok', 'um', 'uh', 'like', 'know', 'think', 'get', 'got', 'would',\n    'could', 'want', 'need', 'see', 'go', 'going', 'come', 'let', 'one', 'two', 'make'\n  ]);\n\n  // Convert to lowercase and split into words\n  const words = transcript\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, ' ') // Replace punctuation with spaces\n    .split(/\\s+/)\n    .filter(word =>\n      word.length > 3 && // At least 4 characters\n      !stopWords.has(word) &&\n      !/^\\d+$/.test(word) // Not just numbers\n    );\n\n  // Count word frequency\n  const wordCount = new Map<string, number>();\n  words.forEach(word => {\n    wordCount.set(word, (wordCount.get(word) || 0) + 1);\n  });\n\n  // Get top keywords (mentioned at least twice, sorted by frequency)\n  const keywords = Array.from(wordCount.entries())\n    .filter(([_, count]) => count >= 2)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 20) // Top 20 keywords\n    .map(([word]) => word);\n\n  return keywords;\n}\n\n// Helper: Store keywords in database with sentiment tracking\nasync function storeKeywords(\n  keywords: string[],\n  userId: string,\n  sentiment: string,\n  db: D1Database\n): Promise<void> {\n  if (keywords.length === 0) return;\n\n  const timestamp = Date.now();\n\n  // Convert sentiment string to numeric score for averaging\n  // Positive = 1, Neutral = 0, Negative = -1\n  let sentimentScore = 0;\n  if (sentiment === 'Positive') sentimentScore = 1;\n  else if (sentiment === 'Negative') sentimentScore = -1;\n\n  for (const keyword of keywords) {\n    try {\n      // Check if keyword already exists for this user\n      const existing = await db.prepare(\n        `SELECT id, count, positive_count, neutral_count, negative_count, avg_sentiment\n         FROM call_keywords WHERE user_id = ? AND keyword = ?`\n      ).bind(userId, keyword).first() as any;\n\n      if (existing) {\n        // Calculate new counts\n        const newPositiveCount = existing.positive_count + (sentiment === 'Positive' ? 1 : 0);\n        const newNeutralCount = existing.neutral_count + (sentiment === 'Neutral' ? 1 : 0);\n        const newNegativeCount = existing.negative_count + (sentiment === 'Negative' ? 1 : 0);\n        const newTotalCount = existing.count + 1;\n\n        // Calculate new average sentiment\n        const newAvgSentiment = ((existing.avg_sentiment * existing.count) + sentimentScore) / newTotalCount;\n\n        // Update with new sentiment data\n        await db.prepare(\n          `UPDATE call_keywords\n           SET count = ?, positive_count = ?, neutral_count = ?, negative_count = ?,\n               avg_sentiment = ?, last_detected_at = ?\n           WHERE id = ?`\n        ).bind(\n          newTotalCount,\n          newPositiveCount,\n          newNeutralCount,\n          newNegativeCount,\n          newAvgSentiment,\n          timestamp,\n          existing.id\n        ).run();\n      } else {\n        // Insert new keyword with sentiment\n        const initialPositiveCount = sentiment === 'Positive' ? 1 : 0;\n        const initialNeutralCount = sentiment === 'Neutral' ? 1 : 0;\n        const initialNegativeCount = sentiment === 'Negative' ? 1 : 0;\n\n        await db.prepare(\n          `INSERT INTO call_keywords\n           (id, user_id, keyword, count, positive_count, neutral_count, negative_count,\n            avg_sentiment, last_detected_at, created_at)\n           VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?)`\n        ).bind(\n          generateId(),\n          userId,\n          keyword,\n          initialPositiveCount,\n          initialNeutralCount,\n          initialNegativeCount,\n          sentimentScore,\n          timestamp,\n          timestamp\n        ).run();\n      }\n    } catch (error) {\n      console.error('Error storing keyword:', keyword, error);\n    }\n  }\n}\n\n// Helper: Lookup caller info using Twilio API\ninterface TwilioCallerInfo {\n  callerName: string | null;\n  callerType: string | null;\n  carrierName: string | null;\n  lineType: string | null;\n}\n\nasync function lookupCallerWithTwilio(\n  phoneNumber: string,\n  twilioAccountSid: string,\n  twilioAuthToken: string\n): Promise<TwilioCallerInfo | null> {\n  try {\n    // Twilio Lookup API requires phone number in E.164 format (+1234567890)\n    const cleanNumber = phoneNumber.replace(/[^\\d+]/g, '');\n\n    const response = await fetch(\n      `https://lookups.twilio.com/v2/PhoneNumbers/${encodeURIComponent(cleanNumber)}?Fields=caller_name,line_type_intelligence`,\n      {\n        method: 'GET',\n        headers: {\n          'Authorization': 'Basic ' + btoa(`${twilioAccountSid}:${twilioAuthToken}`)\n        }\n      }\n    );\n\n    if (!response.ok) {\n      console.error('Twilio API error:', response.status, await response.text());\n      return null;\n    }\n\n    const data = await response.json() as any;\n\n    return {\n      callerName: data.caller_name?.caller_name || null,\n      callerType: data.caller_name?.caller_type || null,\n      carrierName: data.line_type_intelligence?.carrier_name || null,\n      lineType: data.line_type_intelligence?.type || null\n    };\n  } catch (error) {\n    console.error('Error looking up caller with Twilio:', error);\n    return null;\n  }\n}\n\n// Helper: Trigger scheduling webhook when appointment is booked\nasync function triggerSchedulingWebhook(env: Env, userId: string, callId: string): Promise<void> {\n  try {\n    // Get active scheduling triggers for this user\n    const triggers = await env.DB.prepare(\n      'SELECT * FROM scheduling_triggers WHERE user_id = ? AND is_active = 1'\n    ).bind(userId).all();\n\n    if (!triggers.results || triggers.results.length === 0) {\n      console.log('No active scheduling triggers found for user:', userId);\n      return;\n    }\n\n    // Get call data with enhanced data\n    const call = await env.DB.prepare(`\n      SELECT\n        wc.*,\n        ar.result_data as enhanced_data\n      FROM webhook_calls wc\n      LEFT JOIN addon_results ar ON ar.call_id = wc.id AND ar.addon_type = 'enhanced_data'\n      WHERE wc.id = ?\n    `).bind(callId).first() as any;\n\n    if (!call) {\n      console.error('Call not found:', callId);\n      return;\n    }\n\n    // Build webhook payload\n    const payload: any = {\n      name: call.customer_name || 'Unknown',\n      email: call.customer_email || null,\n      phone: call.customer_number || call.phone_number || null,\n      phone_being_called: call.phone_number || null,\n      appointment_date: call.appointment_date,\n      appointment_time: call.appointment_time,\n      appointment_type: call.appointment_type || null,\n      appointment_notes: call.appointment_notes || null,\n      recording: call.recording_url || null,\n      call_summary: call.summary || null,\n      call_id: call.id,\n      intent: call.intent,\n      sentiment: call.sentiment,\n      outcome: call.outcome\n    };\n\n    // Add enhanced data if available and trigger is configured to send it\n    for (const trigger of triggers.results) {\n      const triggerData = trigger as any;\n\n      if (triggerData.send_enhanced_data && call.enhanced_data) {\n        try {\n          payload.enhanced_data = JSON.parse(call.enhanced_data);\n        } catch (e) {\n          console.error('Error parsing enhanced data:', e);\n        }\n      }\n\n      // Send webhook\n      try {\n        const response = await fetch(triggerData.destination_url, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Trigger-Type': 'appointment-scheduled',\n            'X-Call-ID': callId\n          },\n          body: JSON.stringify(payload)\n        });\n\n        const responseBody = await response.text();\n        const logId = generateId();\n\n        // Log the webhook delivery\n        await env.DB.prepare(\n          `INSERT INTO scheduling_trigger_logs\n           (id, trigger_id, call_id, status, http_status, response_body, error_message, payload_sent, created_at)\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\n        ).bind(\n          logId,\n          triggerData.id,\n          callId,\n          response.ok ? 'success' : 'error',\n          response.status,\n          responseBody.substring(0, 1000), // Limit response body size\n          response.ok ? null : `HTTP ${response.status}: ${responseBody}`,\n          JSON.stringify(payload),\n          now()\n        ).run();\n\n        console.log(`Scheduling webhook sent to ${triggerData.destination_url}: ${response.status}`);\n      } catch (error: any) {\n        const logId = generateId();\n\n        // Log the error\n        await env.DB.prepare(\n          `INSERT INTO scheduling_trigger_logs\n           (id, trigger_id, call_id, status, http_status, response_body, error_message, payload_sent, created_at)\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\n        ).bind(\n          logId,\n          triggerData.id,\n          callId,\n          'error',\n          null,\n          null,\n          error.message || 'Unknown error',\n          JSON.stringify(payload),\n          now()\n        ).run();\n\n        console.error('Error sending scheduling webhook:', error);\n      }\n    }\n  } catch (error) {\n    console.error('Error in triggerSchedulingWebhook:', error);\n  }\n}\n\n// Helper: Extract user from Authorization header\nasync function getUserFromToken(request: Request, env: Env): Promise<string | null> {\n  const authHeader = request.headers.get('Authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return null;\n  }\n\n  const token = authHeader.substring(7);\n  const secret = env.JWT_SECRET || 'default-secret-change-me';\n  const decoded = await verifyToken(token, secret);\n\n  if (!decoded) {\n    return null;\n  }\n\n  return decoded.userId;\n}\n\n// Helper: Get effective user ID for workspace context\n// Returns workspace owner's user_id if workspace is selected, otherwise the authenticated user's ID\nasync function getEffectiveUserId(env: Env, userId: string): Promise<{ effectiveUserId: string; isWorkspaceContext: boolean }> {\n  const settings = await env.DB.prepare(\n    'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n  ).bind(userId).first() as any;\n\n  if (!settings || !settings.selected_workspace_id) {\n    return { effectiveUserId: userId, isWorkspaceContext: false };\n  }\n\n  // Verify user has access to this workspace\n  const workspace = await env.DB.prepare(\n    'SELECT owner_user_id FROM workspaces WHERE id = ?'\n  ).bind(settings.selected_workspace_id).first() as any;\n\n  if (!workspace) {\n    return { effectiveUserId: userId, isWorkspaceContext: false };\n  }\n\n  // Check if user is owner or active member\n  const isOwner = workspace.owner_user_id === userId;\n  const membership = await env.DB.prepare(\n    'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n  ).bind(settings.selected_workspace_id, userId).first() as any;\n\n  if (isOwner || membership) {\n    return { effectiveUserId: workspace.owner_user_id, isWorkspaceContext: true };\n  }\n\n  // User doesn't have access, fall back to personal\n  return { effectiveUserId: userId, isWorkspaceContext: false };\n}\n\n// Helper: Get workspace settings for a user (finds their workspace and returns its credentials)\nasync function getWorkspaceSettingsForUser(env: Env, userId: string): Promise<{\n  private_key?: string;\n  openai_api_key?: string;\n  twilio_account_sid?: string;\n  twilio_auth_token?: string;\n  transfer_phone_number?: string;\n} | null> {\n  // Find user's workspace (they own it or are a member)\n  const userSettings = await env.DB.prepare(\n    'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n  ).bind(userId).first() as any;\n\n  if (!userSettings || !userSettings.selected_workspace_id) {\n    // User has no workspace, check if they own one\n    const ownedWorkspace = await env.DB.prepare(\n      'SELECT id FROM workspaces WHERE owner_user_id = ?'\n    ).bind(userId).first() as any;\n\n    if (ownedWorkspace) {\n      const wsSettings = await env.DB.prepare(\n        'SELECT private_key, openai_api_key, twilio_account_sid, twilio_auth_token, transfer_phone_number FROM workspace_settings WHERE workspace_id = ?'\n      ).bind(ownedWorkspace.id).first() as any;\n      return wsSettings || null;\n    }\n    return null;\n  }\n\n  const workspaceId = userSettings.selected_workspace_id;\n  let wsSettings = await env.DB.prepare(\n    'SELECT private_key, openai_api_key, twilio_account_sid, twilio_auth_token, transfer_phone_number FROM workspace_settings WHERE workspace_id = ?'\n  ).bind(workspaceId).first() as any;\n\n  // FALLBACK: If workspace_settings is empty, try user_settings (migration path)\n  if (!wsSettings || !wsSettings.private_key) {\n    const workspace = await env.DB.prepare(\n      'SELECT owner_user_id FROM workspaces WHERE id = ?'\n    ).bind(workspaceId).first() as any;\n\n    if (workspace) {\n      const ownerSettings = await env.DB.prepare(\n        'SELECT private_key, openai_api_key, twilio_account_sid, twilio_auth_token, transfer_phone_number FROM user_settings WHERE user_id = ?'\n      ).bind(workspace.owner_user_id).first() as any;\n\n      if (ownerSettings && ownerSettings.private_key) {\n        wsSettings = ownerSettings;\n      }\n    }\n  }\n\n  return wsSettings || null;\n}\n\n// Helper: Enhanced Data addon - fetch phone number enrichment\nasync function executeEnhancedDataAddon(\n  phoneNumber: string\n): Promise<any> {\n  try {\n    const response = await fetch(\n      `https://enhance-data-production.up.railway.app/phone?phone=${encodeURIComponent(phoneNumber)}`,\n      {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    if (!response.ok) {\n      return null;\n    }\n\n    return await response.json();\n  } catch (error) {\n    console.error('Enhanced Data addon error:', error);\n    return null;\n  }\n}\n\n// Helper: Process addons for a call\nasync function processAddonsForCall(\n  env: Env,\n  userId: string,\n  callId: string,\n  customerPhone: string | null\n): Promise<void> {\n  if (!customerPhone) {\n    return;\n  }\n\n  try {\n    // Initialize cache\n    const cache = new VoiceAICache(env.CACHE);\n\n    // Get enabled addons for user\n    const enabledAddons = await env.DB.prepare(\n      'SELECT addon_type, settings FROM user_addons WHERE user_id = ? AND is_enabled = 1'\n    ).bind(userId).all();\n\n    if (!enabledAddons.results || enabledAddons.results.length === 0) {\n      return;\n    }\n\n    // Process each enabled addon\n    for (const addon of enabledAddons.results as any[]) {\n      const startTime = Date.now();\n      let status = 'failed';\n      let resultData = null;\n      let errorMessage: string | null = null;\n\n      try {\n        if (addon.addon_type === 'enhanced_data') {\n          // Check cache first\n          const cachedData = await cache.getCachedEnhancedData(userId, callId);\n          if (cachedData) {\n            console.log(`Cache HIT for enhanced data: callId=${callId}`);\n            resultData = cachedData;\n            status = 'success';\n          } else {\n            console.log(`Cache MISS for enhanced data: callId=${callId}`);\n            resultData = await executeEnhancedDataAddon(customerPhone);\n            status = resultData ? 'success' : 'failed';\n            if (!resultData) {\n              errorMessage = 'Failed to fetch enhanced data';\n            } else {\n              // Cache the result for 30 minutes\n              await cache.cacheEnhancedData(userId, callId, resultData, CACHE_TTL.ENHANCED_DATA);\n            }\n          }\n        }\n        // Add more addon types here in the future\n      } catch (error: any) {\n        errorMessage = error.message || 'Unknown error';\n      }\n\n      const executionTime = Date.now() - startTime;\n\n      // Store addon result\n      await env.DB.prepare(\n        `INSERT INTO addon_results (\n          id, call_id, user_id, addon_type, status, result_data, error_message, execution_time_ms, created_at\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\n      ).bind(\n        generateId(),\n        callId,\n        userId,\n        addon.addon_type,\n        status,\n        resultData ? JSON.stringify(resultData) : null,\n        errorMessage,\n        executionTime,\n        now()\n      ).run();\n    }\n  } catch (error) {\n    console.error('Error processing addons:', error);\n  }\n}\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    const url = new URL(request.url);\n\n    // Handle CORS preflight\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    try {\n      // ============================================\n      // AUTHENTICATION ENDPOINTS\n      // ============================================\n\n      // Register new user\n      if (url.pathname === '/api/auth/register' && request.method === 'POST') {\n        const { email, password, name } = await request.json() as any;\n\n        if (!email || !password) {\n          return jsonResponse({ error: 'Email and password required' }, 400);\n        }\n\n        // Check if user exists\n        const existing = await env.DB.prepare(\n          'SELECT id FROM users WHERE email = ?'\n        ).bind(email).first();\n\n        if (existing) {\n          return jsonResponse({ error: 'Email already registered' }, 409);\n        }\n\n        // Create user\n        const userId = generateId();\n        const passwordHash = await hashPassword(password);\n        const timestamp = now();\n\n        await env.DB.prepare(\n          'INSERT INTO users (id, email, password_hash, name, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)'\n        ).bind(userId, email, passwordHash, name || null, timestamp, timestamp).run();\n\n        // Generate token\n        const secret = env.JWT_SECRET || 'default-secret-change-me';\n        const token = await generateToken(userId, secret);\n\n        // Create session\n        const sessionId = generateId();\n        const tokenHash = await hashPassword(token);\n        const expiresAt = timestamp + (7 * 24 * 60 * 60); // 7 days\n\n        await env.DB.prepare(\n          'INSERT INTO sessions (id, user_id, token_hash, expires_at, created_at) VALUES (?, ?, ?, ?, ?)'\n        ).bind(sessionId, userId, tokenHash, expiresAt, timestamp).run();\n\n        // Check for pending invitations for this email\n        const pendingInvitations = await env.DB.prepare(\n          'SELECT id, workspace_id, role, token, expires_at FROM workspace_invitations WHERE email = ? AND status = \\\"pending\\\" AND expires_at > ?'\n        ).bind(email, timestamp).all();\n\n        let defaultWorkspaceId: string | null = null;\n\n        if (pendingInvitations.results && pendingInvitations.results.length > 0) {\n          // User has pending invitations - accept them automatically\n          for (const invitation of pendingInvitations.results as any[]) {\n            // Add user to workspace\n            const membershipId = generateId();\n            await env.DB.prepare(\n              'INSERT INTO workspace_members (id, workspace_id, user_id, role, status, invited_by_user_id, invited_at, joined_at, created_at, updated_at) VALUES (?, ?, ?, ?, \\\"active\\\", ?, ?, ?, ?, ?)'\n            ).bind(\n              membershipId,\n              invitation.workspace_id,\n              userId,\n              invitation.role,\n              null, // We don't have invited_by stored yet in old invitations\n              timestamp,\n              timestamp,\n              timestamp,\n              timestamp\n            ).run();\n\n            // Mark invitation as accepted\n            await env.DB.prepare(\n              'UPDATE workspace_invitations SET status = \\\"accepted\\\", accepted_at = ? WHERE id = ?'\n            ).bind(timestamp, invitation.id).run();\n\n            // Use first invited workspace as default\n            if (!defaultWorkspaceId) {\n              defaultWorkspaceId = invitation.workspace_id;\n            }\n          }\n        }\n\n        // Create default workspace for new user only if they don't have invitations\n        if (!defaultWorkspaceId) {\n          const workspaceId = 'ws_' + generateId();\n          const workspaceName = name?.trim() || email.split('@')[0] || 'My Workspace';\n          await env.DB.prepare(\n            'INSERT INTO workspaces (id, name, owner_user_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?)'\n          ).bind(workspaceId, workspaceName, userId, timestamp, timestamp).run();\n          defaultWorkspaceId = workspaceId;\n        }\n\n        // Create empty settings\n        const settingsId = generateId();\n        const encryptionSalt = generateSalt();\n\n        await env.DB.prepare(\n          'INSERT INTO user_settings (id, user_id, encryption_salt, selected_workspace_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)'\n        ).bind(settingsId, userId, encryptionSalt, defaultWorkspaceId, timestamp, timestamp).run();\n\n        return jsonResponse({\n          token,\n          user: {\n            id: userId,\n            email,\n            name: name || null\n          }\n        });\n      }\n\n      // Login\n      if (url.pathname === '/api/auth/login' && request.method === 'POST') {\n        const { email, password } = await request.json() as any;\n\n        if (!email || !password) {\n          return jsonResponse({ error: 'Email and password required' }, 400);\n        }\n\n        // Find user\n        const user = await env.DB.prepare(\n          'SELECT id, email, password_hash, name FROM users WHERE email = ?'\n        ).bind(email).first() as any;\n\n        if (!user) {\n          return jsonResponse({ error: 'Invalid credentials' }, 401);\n        }\n\n        // Verify password\n        const valid = await verifyPassword(password, user.password_hash);\n        if (!valid) {\n          return jsonResponse({ error: 'Invalid credentials' }, 401);\n        }\n\n        // Update last login\n        await env.DB.prepare(\n          'UPDATE users SET last_login_at = ? WHERE id = ?'\n        ).bind(now(), user.id).run();\n\n        // Generate token\n        const secret = env.JWT_SECRET || 'default-secret-change-me';\n        const token = await generateToken(user.id, secret);\n\n        // Create session\n        const sessionId = generateId();\n        const tokenHash = await hashPassword(token);\n        const timestamp = now();\n        const expiresAt = timestamp + (7 * 24 * 60 * 60); // 7 days\n\n        await env.DB.prepare(\n          'INSERT INTO sessions (id, user_id, token_hash, expires_at, created_at) VALUES (?, ?, ?, ?, ?)'\n        ).bind(sessionId, user.id, tokenHash, expiresAt, timestamp).run();\n\n        return jsonResponse({\n          token,\n          user: {\n            id: user.id,\n            email: user.email,\n            name: user.name\n          }\n        });\n      }\n\n      // Logout\n      if (url.pathname === '/api/auth/logout' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Delete all sessions for this user (optional: could delete just current session)\n        await env.DB.prepare(\n          'DELETE FROM sessions WHERE user_id = ?'\n        ).bind(userId).run();\n\n        return jsonResponse({ message: 'Logged out successfully' });\n      }\n\n      // Get current user\n      if (url.pathname === '/api/auth/me' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const user = await env.DB.prepare(\n          'SELECT id, email, name, created_at FROM users WHERE id = ?'\n        ).bind(userId).first() as any;\n\n        if (!user) {\n          return jsonResponse({ error: 'User not found' }, 404);\n        }\n\n        return jsonResponse({\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          createdAt: user.created_at\n        });\n      }\n\n      // ============================================\n      // USER SETTINGS ENDPOINTS (Protected)\n      // ============================================\n\n      // Get user settings\n      // Get settings - workspace-scoped (returns workspace owner's credentials)\n      if (url.pathname === '/api/settings' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get user's selected workspace\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          // No workspace selected, return empty settings\n          return jsonResponse({\n            privateKey: null,\n            publicKey: null,\n            selectedAssistantId: null,\n            selectedPhoneId: null,\n            selectedOrgId: null,\n            selectedWorkspaceId: null,\n            openaiApiKey: null,\n            twilioAccountSid: null,\n            twilioAuthToken: null,\n            transferPhoneNumber: null\n          });\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify user has access to this workspace\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status, role FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        // Check if user is owner or admin\n        const isOwnerOrAdmin = isOwner || (membership && membership.role === 'admin');\n\n        // Get workspace settings (workspace owner's credentials)\n        const wsSettings = await env.DB.prepare(\n          'SELECT private_key, public_key, selected_assistant_id, selected_phone_id, selected_org_id, openai_api_key, twilio_account_sid, twilio_auth_token, transfer_phone_number, salesforce_access_token, salesforce_refresh_token, salesforce_instance_url, salesforce_user_id, salesforce_email, salesforce_connected_at FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        // FALLBACK: If workspace_settings is empty, try to get from user_settings (migration path)\n        let finalSettings = wsSettings;\n        if (!wsSettings || !wsSettings.private_key) {\n          const ownerSettings = await env.DB.prepare(\n            'SELECT private_key, public_key, selected_assistant_id, selected_phone_id, selected_org_id, openai_api_key, twilio_account_sid, twilio_auth_token, transfer_phone_number FROM user_settings WHERE user_id = ?'\n          ).bind(workspace.owner_user_id).first() as any;\n\n          if (ownerSettings && ownerSettings.private_key) {\n            finalSettings = ownerSettings;\n\n            // Auto-migrate to workspace_settings if user is owner or admin\n            if (isOwnerOrAdmin) {\n              const timestamp = Date.now();\n              const wsSettingsId = generateId();\n\n              await env.DB.prepare(\n                `INSERT OR REPLACE INTO workspace_settings (\n                  id, workspace_id, private_key, public_key, openai_api_key,\n                  twilio_account_sid, twilio_auth_token, transfer_phone_number,\n                  selected_assistant_id, selected_phone_id, selected_org_id,\n                  created_at, updated_at\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n              ).bind(\n                wsSettingsId,\n                workspaceId,\n                ownerSettings.private_key,\n                ownerSettings.public_key,\n                ownerSettings.openai_api_key,\n                ownerSettings.twilio_account_sid,\n                ownerSettings.twilio_auth_token,\n                ownerSettings.transfer_phone_number,\n                ownerSettings.selected_assistant_id,\n                ownerSettings.selected_phone_id,\n                ownerSettings.selected_org_id,\n                timestamp,\n                timestamp\n              ).run();\n\n              console.log(`Auto-migrated settings for workspace ${workspaceId}`);\n            }\n          }\n        }\n\n        return jsonResponse({\n          privateKey: finalSettings?.private_key || null,\n          publicKey: finalSettings?.public_key || null,\n          selectedAssistantId: finalSettings?.selected_assistant_id || null,\n          selectedPhoneId: finalSettings?.selected_phone_id || null,\n          selectedOrgId: finalSettings?.selected_org_id || null,\n          selectedWorkspaceId: workspaceId,\n          openaiApiKey: finalSettings?.openai_api_key || null,\n          twilioAccountSid: finalSettings?.twilio_account_sid || null,\n          twilioAuthToken: finalSettings?.twilio_auth_token || null,\n          transferPhoneNumber: finalSettings?.transfer_phone_number || null,\n          salesforceAccessToken: finalSettings?.salesforce_access_token || null,\n          salesforceRefreshToken: finalSettings?.salesforce_refresh_token || null,\n          salesforceInstanceUrl: finalSettings?.salesforce_instance_url || null,\n          salesforceUserId: finalSettings?.salesforce_user_id || null,\n          salesforceEmail: finalSettings?.salesforce_email || null,\n          salesforceConnectedAt: finalSettings?.salesforce_connected_at || null,\n          isWorkspaceOwner: isOwnerOrAdmin\n        });\n      }\n\n      // Update settings - workspace-scoped (only workspace owner can update)\n      if (url.pathname === '/api/settings' && request.method === 'PUT') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const {\n          privateKey,\n          publicKey,\n          selectedAssistantId,\n          selectedPhoneId,\n          selectedOrgId,\n          selectedWorkspaceId,\n          openaiApiKey,\n          twilioAccountSid,\n          twilioAuthToken,\n          transferPhoneNumber,\n          salesforceAccessToken,\n          salesforceRefreshToken,\n          salesforceInstanceUrl,\n          salesforceUserId,\n          salesforceEmail,\n          salesforceConnectedAt\n        } = await request.json() as any;\n\n        // Validate workspace selection\n        if (!selectedWorkspaceId) {\n          return jsonResponse({ error: 'Workspace selection is required' }, 400);\n        }\n\n        // Verify user is workspace owner\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(selectedWorkspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        if (workspace.owner_user_id !== userId) {\n          return jsonResponse({ error: 'Only workspace owner can update API credentials' }, 403);\n        }\n\n        const timestamp = now();\n\n        // Update or insert workspace settings\n        const existing = await env.DB.prepare(\n          'SELECT id FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(selectedWorkspaceId).first() as any;\n\n        if (existing) {\n          await env.DB.prepare(\n            'UPDATE workspace_settings SET private_key = ?, public_key = ?, selected_assistant_id = ?, selected_phone_id = ?, selected_org_id = ?, openai_api_key = ?, twilio_account_sid = ?, twilio_auth_token = ?, transfer_phone_number = ?, salesforce_access_token = ?, salesforce_refresh_token = ?, salesforce_instance_url = ?, salesforce_user_id = ?, salesforce_email = ?, salesforce_connected_at = ?, updated_at = ? WHERE workspace_id = ?'\n          ).bind(\n            privateKey || null,\n            publicKey || null,\n            selectedAssistantId || null,\n            selectedPhoneId || null,\n            selectedOrgId || null,\n            openaiApiKey || null,\n            twilioAccountSid || null,\n            twilioAuthToken || null,\n            transferPhoneNumber || null,\n            salesforceAccessToken || null,\n            salesforceRefreshToken || null,\n            salesforceInstanceUrl || null,\n            salesforceUserId || null,\n            salesforceEmail || null,\n            salesforceConnectedAt || null,\n            timestamp,\n            selectedWorkspaceId\n          ).run();\n        } else {\n          const settingsId = generateId();\n          await env.DB.prepare(\n            'INSERT INTO workspace_settings (id, workspace_id, private_key, public_key, selected_assistant_id, selected_phone_id, selected_org_id, openai_api_key, twilio_account_sid, twilio_auth_token, transfer_phone_number, salesforce_access_token, salesforce_refresh_token, salesforce_instance_url, salesforce_user_id, salesforce_email, salesforce_connected_at, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'\n          ).bind(\n            settingsId,\n            selectedWorkspaceId,\n            privateKey || null,\n            publicKey || null,\n            selectedAssistantId || null,\n            selectedPhoneId || null,\n            selectedOrgId || null,\n            openaiApiKey || null,\n            twilioAccountSid || null,\n            twilioAuthToken || null,\n            transferPhoneNumber || null,\n            salesforceAccessToken || null,\n            salesforceRefreshToken || null,\n            salesforceInstanceUrl || null,\n            salesforceUserId || null,\n            salesforceEmail || null,\n            salesforceConnectedAt || null,\n            timestamp,\n            timestamp\n          ).run();\n        }\n\n        // Update user's selected workspace\n        await env.DB.prepare(\n          'UPDATE user_settings SET selected_workspace_id = ?, updated_at = ? WHERE user_id = ?'\n        ).bind(selectedWorkspaceId, timestamp, userId).run();\n\n        return jsonResponse({ message: 'Settings updated successfully' });\n      }\n\n      // ============================================\n      // WORKSPACES ENDPOINTS (Protected)\n      // ============================================\n\n      // List workspaces for current user (owner or active member)\n      if (url.pathname === '/api/workspaces' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const query = `\n          SELECT DISTINCT w.id, w.name, w.owner_user_id, w.created_at, w.updated_at,\n            CASE WHEN w.owner_user_id = ? THEN 'owner' ELSE wm.role END AS role,\n            CASE WHEN w.owner_user_id = ? THEN 'active' ELSE wm.status END AS status\n          FROM workspaces w\n          LEFT JOIN workspace_members wm\n            ON wm.workspace_id = w.id AND wm.user_id = ?\n          WHERE w.owner_user_id = ? OR wm.user_id = ?\n          ORDER BY w.created_at DESC`;\n\n        const { results } = await env.DB.prepare(query).bind(userId, userId, userId, userId, userId).all();\n        return jsonResponse({ workspaces: results || [] });\n      }\n\n      // Create workspace - DISABLED: Users get one workspace automatically on registration\n      // Keeping endpoint for backward compatibility but returning error\n      if (url.pathname === '/api/workspaces' && request.method === 'POST') {\n        return jsonResponse({ error: 'Workspace creation is not allowed. Each user automatically gets one workspace on registration.' }, 403);\n      }\n\n      // Invite a member to a workspace by email (supports pending invitations for non-existing users)\n      if (url.pathname.startsWith('/api/workspaces/') && url.pathname.endsWith('/invite') && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const parts = url.pathname.split('/');\n        const workspaceId = parts[3];\n        const { email, role } = await request.json() as any;\n        if (!email) {\n          return jsonResponse({ error: 'Email is required' }, 400);\n        }\n\n        // Verify requester has permission (owner or admin)\n        const ws = await env.DB.prepare('SELECT owner_user_id FROM workspaces WHERE id = ?').bind(workspaceId).first() as any;\n        if (!ws) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n        if (ws.owner_user_id !== userId) {\n          const membership = await env.DB.prepare(\n            'SELECT role FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \\\"active\\\"'\n          ).bind(workspaceId, userId).first() as any;\n          if (!membership || (membership.role !== 'admin' && membership.role !== 'owner')) {\n            return jsonResponse({ error: 'Forbidden' }, 403);\n          }\n        }\n\n        const timestamp = now();\n\n        // Check if user exists\n        const user = await env.DB.prepare('SELECT id FROM users WHERE email = ?').bind(email).first() as any;\n\n        if (user) {\n          // User exists - add them directly as active member\n          const membershipId = generateId();\n          try {\n            await env.DB.prepare(\n              'INSERT INTO workspace_members (id, workspace_id, user_id, role, status, invited_by_user_id, invited_at, joined_at, created_at, updated_at) VALUES (?, ?, ?, ?, \\\"active\\\", ?, ?, ?, ?, ?)'\n            ).bind(membershipId, workspaceId, user.id, role || 'member', userId, timestamp, timestamp, timestamp, timestamp).run();\n          } catch (e) {\n            // If unique constraint, update status/role\n            await env.DB.prepare(\n              'UPDATE workspace_members SET role = ?, status = \\\"active\\\", invited_by_user_id = ?, invited_at = ?, joined_at = ?, updated_at = ? WHERE workspace_id = ? AND user_id = ?'\n            ).bind(role || 'member', userId, timestamp, timestamp, timestamp, workspaceId, user.id).run();\n          }\n          return jsonResponse({ success: true, message: 'User added to workspace' });\n        } else {\n          // User doesn't exist - create account with temporary password\n          const temporaryPassword = generateTemporaryPassword();\n          const passwordHash = await hashPassword(temporaryPassword);\n          const newUserId = generateId();\n\n          // Create user account\n          await env.DB.prepare(\n            'INSERT INTO users (id, email, password_hash, name, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)'\n          ).bind(newUserId, email, passwordHash, null, timestamp, timestamp).run();\n\n          // Create default workspace for the new user\n          const newUserWorkspaceId = 'ws_' + generateId();\n          const workspaceName = email.split('@')[0] || 'My Workspace';\n          await env.DB.prepare(\n            'INSERT INTO workspaces (id, name, owner_user_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?)'\n          ).bind(newUserWorkspaceId, workspaceName, newUserId, timestamp, timestamp).run();\n\n          // Create user settings with the invited workspace as selected\n          const settingsId = generateId();\n          const encryptionSalt = generateSalt();\n          await env.DB.prepare(\n            'INSERT INTO user_settings (id, user_id, encryption_salt, selected_workspace_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)'\n          ).bind(settingsId, newUserId, encryptionSalt, workspaceId, timestamp, timestamp).run();\n\n          // Add user to the workspace they were invited to\n          const membershipId = generateId();\n          await env.DB.prepare(\n            'INSERT INTO workspace_members (id, workspace_id, user_id, role, status, invited_by_user_id, invited_at, joined_at, created_at, updated_at) VALUES (?, ?, ?, ?, \\\"active\\\", ?, ?, ?, ?, ?)'\n          ).bind(membershipId, workspaceId, newUserId, role || 'member', userId, timestamp, timestamp, timestamp, timestamp).run();\n\n          // Mark any pending invitations as accepted\n          await env.DB.prepare(\n            'UPDATE workspace_invitations SET status = \\\"accepted\\\", accepted_at = ? WHERE email = ? AND workspace_id = ? AND status = \\\"pending\\\"'\n          ).bind(timestamp, email, workspaceId).run();\n\n          return jsonResponse({\n            success: true,\n            message: 'User account created and added to workspace',\n            credentials: {\n              email: email,\n              temporaryPassword: temporaryPassword\n            }\n          });\n        }\n      }\n\n      // Get workspace members\n      if (url.pathname.startsWith('/api/workspaces/') && url.pathname.endsWith('/members') && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const parts = url.pathname.split('/');\n        const workspaceId = parts[3];\n\n        // Verify user has access to this workspace\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id, name FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status, role FROM workspace_members WHERE workspace_id = ? AND user_id = ?'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && (!membership || membership.status !== 'active')) {\n          return jsonResponse({ error: 'Access denied' }, 403);\n        }\n\n        // Get owner info\n        const owner = await env.DB.prepare(\n          'SELECT id, email, name FROM users WHERE id = ?'\n        ).bind(workspace.owner_user_id).first() as any;\n\n        // Get all members including owner\n        const members = await env.DB.prepare(`\n          SELECT wm.id, wm.role, wm.status, wm.joined_at, wm.invited_at,\n                 u.id as user_id, u.email, u.name\n          FROM workspace_members wm\n          JOIN users u ON u.id = wm.user_id\n          WHERE wm.workspace_id = ? AND wm.status = 'active'\n          ORDER BY wm.joined_at DESC\n        `).bind(workspaceId).all() as any;\n\n        const membersList = (members.results || []).map((m: any) => ({\n          id: m.user_id,\n          email: m.email,\n          name: m.name,\n          role: m.role,\n          status: m.status,\n          joinedAt: m.joined_at,\n        }));\n\n        // Add owner to list if not already included\n        const ownerInList = membersList.find((m: any) => m.id === owner.id);\n        if (!ownerInList) {\n          membersList.unshift({\n            id: owner.id,\n            email: owner.email,\n            name: owner.name,\n            role: 'owner',\n            status: 'active',\n            joinedAt: null,\n          });\n        }\n\n        return jsonResponse({\n          workspace: { id: workspaceId, name: workspace.name },\n          members: membersList,\n        });\n      }\n\n      // Remove member from workspace\n      if (url.pathname.includes('/api/workspaces/') && url.pathname.includes('/members/') && request.method === 'DELETE') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const parts = url.pathname.split('/');\n        const workspaceId = parts[3];\n        const memberId = parts[5];\n\n        // Verify user has permission (must be owner or admin)\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT role FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && (!membership || membership.role !== 'admin')) {\n          return jsonResponse({ error: 'Only owners and admins can remove members' }, 403);\n        }\n\n        // Cannot remove owner\n        if (memberId === workspace.owner_user_id) {\n          return jsonResponse({ error: 'Cannot remove workspace owner' }, 400);\n        }\n\n        // Get the member to remove\n        const member = await env.DB.prepare(\n          'SELECT user_id FROM workspace_members WHERE id = ? AND workspace_id = ?'\n        ).bind(memberId, workspaceId).first() as any;\n\n        if (!member) {\n          return jsonResponse({ error: 'Member not found' }, 404);\n        }\n\n        // Remove member\n        await env.DB.prepare(\n          'DELETE FROM workspace_members WHERE id = ? AND workspace_id = ?'\n        ).bind(memberId, workspaceId).run();\n\n        return jsonResponse({ success: true, message: 'Member removed successfully' });\n      }\n\n      // Update member role\n      if (url.pathname.includes('/api/workspaces/') && url.pathname.includes('/members/') && request.method === 'PATCH') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const parts = url.pathname.split('/');\n        const workspaceId = parts[3];\n        const memberId = parts[5];\n        const { role } = await request.json() as any;\n\n        if (!role || !['member', 'admin'].includes(role)) {\n          return jsonResponse({ error: 'Invalid role. Must be \"member\" or \"admin\"' }, 400);\n        }\n\n        // Verify user has permission (must be owner)\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        if (workspace.owner_user_id !== userId) {\n          return jsonResponse({ error: 'Only workspace owner can change roles' }, 403);\n        }\n\n        // Get the member to update\n        const member = await env.DB.prepare(\n          'SELECT user_id FROM workspace_members WHERE id = ? AND workspace_id = ?'\n        ).bind(memberId, workspaceId).first() as any;\n\n        if (!member) {\n          return jsonResponse({ error: 'Member not found' }, 404);\n        }\n\n        // Update role\n        const timestamp = now();\n        await env.DB.prepare(\n          'UPDATE workspace_members SET role = ?, updated_at = ? WHERE id = ? AND workspace_id = ?'\n        ).bind(role, timestamp, memberId, workspaceId).run();\n\n        return jsonResponse({ success: true, message: 'Member role updated successfully' });\n      }\n\n      // ============================================\n      // PHONE NUMBERS ENDPOINTS (Protected)\n      // ============================================\n\n      // Get Twilio phone numbers\n      if (url.pathname === '/api/twilio/phone-numbers' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected. Please select a workspace first.' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT twilio_account_sid, twilio_auth_token FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!settings || !settings.twilio_account_sid || !settings.twilio_auth_token) {\n          return jsonResponse({ error: 'Twilio credentials not configured. Please add your Twilio Account SID and Auth Token in API Configuration.' }, 400);\n        }\n\n        try {\n          // Fetch Twilio phone numbers\n          const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${settings.twilio_account_sid}/IncomingPhoneNumbers.json`;\n          const twilioAuth = btoa(`${settings.twilio_account_sid}:${settings.twilio_auth_token}`);\n          \n          const twilioResponse = await fetch(twilioUrl, {\n            headers: {\n              'Authorization': `Basic ${twilioAuth}`,\n            },\n          });\n\n          if (!twilioResponse.ok) {\n            const errorText = await twilioResponse.text();\n            return jsonResponse({ error: `Twilio API error: ${twilioResponse.status} - ${errorText}` }, 400);\n          }\n\n          const twilioData = await twilioResponse.json() as any;\n          \n          // Filter to voice-capable numbers only\n          const voiceNumbers = (twilioData.incoming_phone_numbers || []).filter((num: any) => \n            num.capabilities?.voice === true\n          ).map((num: any) => ({\n            sid: num.sid,\n            phoneNumber: num.phone_number,\n            friendlyName: num.friendly_name,\n            capabilities: {\n              voice: num.capabilities?.voice || false,\n              sms: num.capabilities?.sms || false,\n            }\n          }));\n\n          return jsonResponse(voiceNumbers);\n        } catch (error: any) {\n          console.error('Error fetching Twilio numbers:', error);\n          return jsonResponse({ error: `Failed to fetch Twilio numbers: ${error.message}` }, 500);\n        }\n      }\n\n      // Import Twilio number to Vapi\n      if (url.pathname === '/api/vapi/import-twilio' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { sid, phoneNumber, name } = await request.json() as any;\n\n        if (!sid && !phoneNumber) {\n          return jsonResponse({ error: 'Either sid or phoneNumber is required' }, 400);\n        }\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected. Please select a workspace first.' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT private_key, twilio_account_sid, twilio_auth_token FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured. Please add your CHAU Voice Engine Private API Key in API Configuration.' }, 400);\n        }\n\n        if (!settings.twilio_account_sid || !settings.twilio_auth_token) {\n          return jsonResponse({ error: 'Twilio credentials not configured. Please add your Twilio Account SID and Auth Token in API Configuration.' }, 400);\n        }\n\n        try {\n          // Import phone number to CHAU Voice Engine\n          // According to Vapi docs, we need to POST to /phone-number with import parameters\n          const vapiUrl = 'https://api.vapi.ai/phone-number';\n          const payload: any = {\n            provider: 'twilio',\n            twilioAccountSid: settings.twilio_account_sid,\n            twilioAuthToken: settings.twilio_auth_token,\n          };\n\n          if (sid) {\n            payload.twilioPhoneNumberSid = sid;\n          } else if (phoneNumber) {\n            payload.number = phoneNumber;\n          }\n\n          if (name) {\n            payload.name = name;\n          }\n\n          // Ensure SMS is disabled, only voice\n          payload.smsEnabled = false;\n\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'POST',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(payload),\n          });\n\n          if (!vapiResponse.ok) {\n            const errorText = await vapiResponse.text();\n            return jsonResponse({ error: `CHAU Voice Engine API error: ${vapiResponse.status} - ${errorText}` }, 400);\n          }\n\n          const vapiData = await vapiResponse.json() as any;\n          \n          return jsonResponse({\n            id: vapiData.id,\n            number: vapiData.number || vapiData.phoneNumber,\n            name: vapiData.name || name,\n          });\n        } catch (error: any) {\n          console.error('Error importing Twilio number:', error);\n          return jsonResponse({ error: `Failed to import Twilio number: ${error.message}` }, 500);\n        }\n      }\n\n      // Create free CHAU Voice Engine phone number\n      if (url.pathname === '/api/vapi/phone-number' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { areaCode, name } = await request.json() as any;\n\n        if (!areaCode || !/^\\d{3}$/.test(areaCode)) {\n          return jsonResponse({ error: 'Valid 3-digit area code is required' }, 400);\n        }\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected. Please select a workspace first.' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT private_key, transfer_phone_number FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured. Please add your CHAU Voice Engine Private API Key in API Configuration.' }, 400);\n        }\n\n        try {\n          // Create free CHAU Voice Engine phone number (provider: \"vapi\")\n          // CHAU Voice Engine provides free US phone numbers - no Twilio purchase needed\n          // Up to 10 free numbers per account\n          const vapiUrl = 'https://api.vapi.ai/phone-number';\n          const payload: any = {\n            provider: 'vapi',\n            numberDesiredAreaCode: areaCode, // Correct field name from Vapi dashboard\n          };\n\n          if (name) {\n            payload.name = name;\n          }\n\n          // Set fallback destination to transfer number if available\n          if (settings.transfer_phone_number) {\n            payload.fallbackDestination = {\n              type: 'number',\n              number: settings.transfer_phone_number,\n            };\n          }\n\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'POST',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(payload),\n          });\n\n          if (!vapiResponse.ok) {\n            let errorText = await vapiResponse.text();\n            try {\n              // Try to parse error JSON to extract meaningful message\n              const errorJson = JSON.parse(errorText);\n              if (errorJson.message) {\n                errorText = errorJson.message;\n              } else if (errorJson.error) {\n                errorText = errorJson.error;\n              }\n            } catch {\n              // If not JSON, use error text as is\n            }\n            return jsonResponse({ error: errorText }, 400);\n          }\n\n          const vapiData = await vapiResponse.json() as any;\n          \n          return jsonResponse({\n            id: vapiData.id,\n            number: vapiData.number || vapiData.phoneNumber,\n            name: vapiData.name || name,\n          });\n        } catch (error: any) {\n          console.error('Error creating CHAU Voice Engine phone number:', error);\n          return jsonResponse({ error: `Failed to create phone number: ${error.message}` }, 500);\n        }\n      }\n\n      // Update phone number assistant assignment\n      if (url.pathname.startsWith('/api/vapi/phone-number/') && url.pathname.endsWith('/assistant') && request.method === 'PATCH') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Extract ID from /api/vapi/phone-number/{id}/assistant\n        const pathParts = url.pathname.split('/').filter(Boolean);\n        const phoneNumberId = pathParts.length >= 4 ? pathParts[3] : null; // ['api', 'vapi', 'phone-number', '{id}', 'assistant']\n        const { assistantId } = await request.json() as any;\n\n        if (!phoneNumberId) {\n          return jsonResponse({ error: 'Phone number ID required' }, 400);\n        }\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected. Please select a workspace first.' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        let settings = await env.DB.prepare(\n          'SELECT private_key FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        // FALLBACK: If workspace_settings is empty, try user_settings\n        if (!settings || !settings.private_key) {\n          const ownerSettings = await env.DB.prepare(\n            'SELECT private_key FROM user_settings WHERE user_id = ?'\n          ).bind(workspace.owner_user_id).first() as any;\n\n          if (ownerSettings && ownerSettings.private_key) {\n            settings = ownerSettings;\n          }\n        }\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured. Please add your CHAU Voice Engine Private API Key in API Configuration.' }, 400);\n        }\n\n        try {\n          // Update phone number via Vapi API\n          const vapiUrl = `https://api.vapi.ai/phone-number/${phoneNumberId}`;\n          const payload: any = {};\n          \n          // If assistantId is null/undefined, set it to null to remove assignment\n          // If assistantId is provided, set it to assign\n          if (assistantId === null || assistantId === undefined || assistantId === '') {\n            payload.assistantId = null;\n          } else {\n            payload.assistantId = assistantId;\n          }\n\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'PATCH',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(payload),\n          });\n\n          if (!vapiResponse.ok) {\n            const errorText = await vapiResponse.text();\n            return jsonResponse({ error: `CHAU Voice Engine API error: ${vapiResponse.status} - ${errorText}` }, 400);\n          }\n\n          const vapiData = await vapiResponse.json() as any;\n          \n          return jsonResponse({\n            success: true,\n            phoneNumber: {\n              id: vapiData.id,\n              number: vapiData.number || vapiData.phoneNumber,\n              assistantId: vapiData.assistantId || null,\n            }\n          });\n        } catch (error: any) {\n          console.error('Error updating phone number assistant:', error);\n          return jsonResponse({ error: `Failed to update phone number: ${error.message}` }, 500);\n        }\n      }\n\n      // ============================================\n      // ASSISTANTS ENDPOINTS (Protected with Caching)\n      // ============================================\n\n      // Get all assistants (cache-first, supports workspace context)\n      if (url.pathname === '/api/assistants' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get user settings including selected_workspace_id\n        const settings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!settings) {\n          return jsonResponse({ error: 'User settings not found' }, 404);\n        }\n\n        // Determine effective user ID for API key and cache lookup\n        let effectiveUserId = userId;\n        let privateKey: string | null = null;\n\n        // If workspace is selected, use workspace settings (workspace-scoped credentials)\n        if (settings.selected_workspace_id) {\n          // Verify user has access to this workspace\n          const workspace = await env.DB.prepare(\n            'SELECT owner_user_id FROM workspaces WHERE id = ?'\n          ).bind(settings.selected_workspace_id).first() as any;\n\n          if (workspace) {\n            // Check if user is owner or active member\n            const isOwner = workspace.owner_user_id === userId;\n            const membership = await env.DB.prepare(\n              'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n            ).bind(settings.selected_workspace_id, userId).first() as any;\n\n            if (isOwner || membership) {\n              // Use workspace settings (workspace-scoped credentials)\n              const wsSettings = await env.DB.prepare(\n                'SELECT private_key FROM workspace_settings WHERE workspace_id = ?'\n              ).bind(settings.selected_workspace_id).first() as any;\n\n              if (wsSettings && wsSettings.private_key) {\n                privateKey = wsSettings.private_key;\n                effectiveUserId = workspace.owner_user_id;\n              } else {\n                // No workspace credentials - return empty list instead of error\n                return jsonResponse({ assistants: [] });\n              }\n            } else {\n              return jsonResponse({ error: 'Access denied to workspace' }, 403);\n            }\n          } else {\n            // Workspace not found - return empty list\n            return jsonResponse({ assistants: [] });\n          }\n        } else {\n          // No workspace selected - return empty list (credentials are now workspace-scoped only)\n          return jsonResponse({ assistants: [] });\n        }\n\n        if (!privateKey) {\n          // No credentials found - return empty list\n          return jsonResponse({ assistants: [] });\n        }\n\n        try {\n          // Check cache first (assistants cached within last 5 minutes are considered fresh)\n          const cacheAgeLimit = now() - (5 * 60); // 5 minutes ago\n          const cached = await env.DB.prepare(\n            'SELECT id, vapi_data, cached_at, updated_at FROM assistants_cache WHERE user_id = ? AND cached_at > ? ORDER BY cached_at DESC'\n          ).bind(effectiveUserId, cacheAgeLimit).all();\n\n          if (cached && cached.results && cached.results.length > 0) {\n            // Return cached data\n            const assistants = cached.results.map((row: any) => JSON.parse(row.vapi_data));\n            return jsonResponse({ assistants, cached: true });\n          }\n\n          // Cache miss or stale - fetch from Vapi\n          const vapiUrl = 'https://api.vapi.ai/assistant';\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'GET',\n            headers: {\n              'Authorization': `Bearer ${privateKey}`,\n              'Content-Type': 'application/json',\n            },\n          });\n\n          if (!vapiResponse.ok) {\n            const errorText = await vapiResponse.text();\n            return jsonResponse({ error: `CHAU Voice Engine API error: ${vapiResponse.status} - ${errorText}` }, 400);\n          }\n\n          const assistants = await vapiResponse.json() as any[];\n          const timestamp = now();\n\n          // Update cache using effective user ID (workspace owner if applicable)\n          for (const assistant of assistants) {\n            await env.DB.prepare(\n              'INSERT OR REPLACE INTO assistants_cache (id, user_id, vapi_data, cached_at, updated_at) VALUES (?, ?, ?, ?, ?)'\n            ).bind(\n              assistant.id,\n              effectiveUserId,\n              JSON.stringify(assistant),\n              timestamp,\n              new Date(assistant.updatedAt || assistant.createdAt).getTime() / 1000 || timestamp\n            ).run();\n          }\n\n          return jsonResponse({ assistants, cached: false });\n        } catch (error: any) {\n          console.error('Error fetching assistants:', error);\n          return jsonResponse({ error: `Failed to fetch assistants: ${error.message}` }, 500);\n        }\n      }\n\n      // Get single assistant (cache-first)\n      if (url.pathname.startsWith('/api/assistants/') && url.pathname !== '/api/assistants' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const assistantId = url.pathname.split('/').pop();\n        if (!assistantId) {\n          return jsonResponse({ error: 'Assistant ID required' }, 400);\n        }\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT private_key FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured' }, 400);\n        }\n\n        const effectiveUserId = workspace.owner_user_id;\n\n        try {\n          // Check cache first (use workspace owner's user_id for cache)\n          const cached = await env.DB.prepare(\n            'SELECT vapi_data, cached_at FROM assistants_cache WHERE id = ? AND user_id = ?'\n          ).bind(assistantId, effectiveUserId).first() as any;\n\n          if (cached) {\n            const cacheAge = now() - cached.cached_at;\n            // If cached within last 5 minutes, use cache\n            if (cacheAge < 5 * 60) {\n              return jsonResponse({ assistant: JSON.parse(cached.vapi_data), cached: true });\n            }\n          }\n\n          // Cache miss or stale - fetch from Vapi\n          const vapiUrl = `https://api.vapi.ai/assistant/${assistantId}`;\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'GET',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n          });\n\n          if (!vapiResponse.ok) {\n            const errorText = await vapiResponse.text();\n            return jsonResponse({ error: `CHAU Voice Engine API error: ${vapiResponse.status} - ${errorText}` }, 400);\n          }\n\n          const assistant = await vapiResponse.json() as any;\n          const timestamp = now();\n\n          // Update cache (use workspace owner's user_id for cache)\n          await env.DB.prepare(\n            'INSERT OR REPLACE INTO assistants_cache (id, user_id, vapi_data, cached_at, updated_at) VALUES (?, ?, ?, ?, ?)'\n          ).bind(\n            assistant.id,\n            effectiveUserId,\n            JSON.stringify(assistant),\n            timestamp,\n            new Date(assistant.updatedAt || assistant.createdAt).getTime() / 1000 || timestamp\n          ).run();\n\n          return jsonResponse({ assistant, cached: false });\n        } catch (error: any) {\n          console.error('Error fetching assistant:', error);\n          return jsonResponse({ error: `Failed to fetch assistant: ${error.message}` }, 500);\n        }\n      }\n\n      // Update assistant (write-through cache)\n      if (url.pathname.startsWith('/api/assistants/') && url.pathname !== '/api/assistants' && request.method === 'PATCH') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const assistantId = url.pathname.split('/').pop();\n        const updates = await request.json() as any;\n\n        if (!assistantId) {\n          return jsonResponse({ error: 'Assistant ID required' }, 400);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT private_key FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured' }, 400);\n        }\n\n        try {\n          // 1. Update in Vapi first (source of truth)\n          const vapiUrl = `https://api.vapi.ai/assistant/${assistantId}`;\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'PATCH',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(updates),\n          });\n\n          if (!vapiResponse.ok) {\n            const errorText = await vapiResponse.text();\n            return jsonResponse({ error: `CHAU Voice Engine API error: ${vapiResponse.status} - ${errorText}` }, 400);\n          }\n\n          const updatedAssistant = await vapiResponse.json() as any;\n          const timestamp = now();\n\n          // 2. Update D1 cache (write-through)\n          await env.DB.prepare(\n            'INSERT OR REPLACE INTO assistants_cache (id, user_id, vapi_data, cached_at, updated_at) VALUES (?, ?, ?, ?, ?)'\n          ).bind(\n            updatedAssistant.id,\n            userId,\n            JSON.stringify(updatedAssistant),\n            timestamp,\n            new Date(updatedAssistant.updatedAt || updatedAssistant.createdAt).getTime() / 1000 || timestamp\n          ).run();\n\n          return jsonResponse({ assistant: updatedAssistant });\n        } catch (error: any) {\n          console.error('Error updating assistant:', error);\n          return jsonResponse({ error: `Failed to update assistant: ${error.message}` }, 500);\n        }\n      }\n\n      // Create assistant (write-through cache)\n      if (url.pathname === '/api/assistants' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const assistantData = await request.json() as any;\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected. Please select a workspace first.' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT private_key FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured. Please configure workspace API keys in Settings.' }, 400);\n        }\n\n        try {\n          // 1. Create in Vapi first (source of truth)\n          const vapiUrl = 'https://api.vapi.ai/assistant';\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'POST',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(assistantData),\n          });\n\n          if (!vapiResponse.ok) {\n            let errorText = await vapiResponse.text();\n            try {\n              // Try to parse error JSON to extract meaningful message\n              const errorJson = JSON.parse(errorText);\n              if (errorJson.message) {\n                errorText = errorJson.message;\n              } else if (errorJson.error) {\n                errorText = errorJson.error;\n              }\n            } catch {\n              // If not JSON, use error text as is\n            }\n            return jsonResponse({ error: errorText }, 400);\n          }\n\n          const newAssistant = await vapiResponse.json() as any;\n          const timestamp = now();\n\n          // 2. Add to D1 cache (write-through) - use workspace owner's user_id for cache\n          const effectiveUserId = workspace.owner_user_id;\n          await env.DB.prepare(\n            'INSERT OR REPLACE INTO assistants_cache (id, user_id, vapi_data, cached_at, updated_at) VALUES (?, ?, ?, ?, ?)'\n          ).bind(\n            newAssistant.id,\n            effectiveUserId,\n            JSON.stringify(newAssistant),\n            timestamp,\n            new Date(newAssistant.updatedAt || newAssistant.createdAt).getTime() / 1000 || timestamp\n          ).run();\n\n          return jsonResponse({ assistant: newAssistant });\n        } catch (error: any) {\n          console.error('Error creating assistant:', error);\n          return jsonResponse({ error: `Failed to create assistant: ${error.message}` }, 500);\n        }\n      }\n\n      // Delete assistant (write-through cache)\n      if (url.pathname.startsWith('/api/assistants/') && url.pathname !== '/api/assistants' && request.method === 'DELETE') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const assistantId = url.pathname.split('/').pop();\n        if (!assistantId) {\n          return jsonResponse({ error: 'Assistant ID required' }, 400);\n        }\n\n        // Get workspace settings (workspace-scoped)\n        const userSettings = await env.DB.prepare(\n          'SELECT selected_workspace_id FROM user_settings WHERE user_id = ?'\n        ).bind(userId).first() as any;\n\n        if (!userSettings || !userSettings.selected_workspace_id) {\n          return jsonResponse({ error: 'No workspace selected' }, 400);\n        }\n\n        const workspaceId = userSettings.selected_workspace_id;\n\n        // Verify workspace access\n        const workspace = await env.DB.prepare(\n          'SELECT owner_user_id FROM workspaces WHERE id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!workspace) {\n          return jsonResponse({ error: 'Workspace not found' }, 404);\n        }\n\n        const isOwner = workspace.owner_user_id === userId;\n        const membership = await env.DB.prepare(\n          'SELECT status FROM workspace_members WHERE workspace_id = ? AND user_id = ? AND status = \"active\"'\n        ).bind(workspaceId, userId).first() as any;\n\n        if (!isOwner && !membership) {\n          return jsonResponse({ error: 'Access denied to workspace' }, 403);\n        }\n\n        const settings = await env.DB.prepare(\n          'SELECT private_key FROM workspace_settings WHERE workspace_id = ?'\n        ).bind(workspaceId).first() as any;\n\n        if (!settings || !settings.private_key) {\n          return jsonResponse({ error: 'CHAU Voice Engine API key not configured' }, 400);\n        }\n\n        const effectiveUserId = workspace.owner_user_id;\n\n        try {\n          // 1. Delete from Vapi first (source of truth)\n          const vapiUrl = `https://api.vapi.ai/assistant/${assistantId}`;\n          const vapiResponse = await fetch(vapiUrl, {\n            method: 'DELETE',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`,\n              'Content-Type': 'application/json',\n            },\n          });\n\n          if (!vapiResponse.ok) {\n            const errorText = await vapiResponse.text();\n            return jsonResponse({ error: `CHAU Voice Engine API error: ${vapiResponse.status} - ${errorText}` }, 400);\n          }\n\n          // 2. Delete from D1 cache (write-through) - use workspace owner's user_id\n          await env.DB.prepare(\n            'DELETE FROM assistants_cache WHERE id = ? AND user_id = ?'\n          ).bind(assistantId, effectiveUserId).run();\n\n          return jsonResponse({ success: true });\n        } catch (error: any) {\n          console.error('Error deleting assistant:', error);\n          return jsonResponse({ error: `Failed to delete assistant: ${error.message}` }, 500);\n        }\n      }\n\n      // ============================================\n      // ADDONS ENDPOINTS (Protected)\n      // ============================================\n\n      // Get user addons configuration\n      if (url.pathname === '/api/addons' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { results } = await env.DB.prepare(\n          'SELECT addon_type, is_enabled, settings FROM user_addons WHERE user_id = ?'\n        ).bind(userId).all();\n\n        return jsonResponse({ addons: results || [] });\n      }\n\n      // Toggle addon on/off\n      if (url.pathname === '/api/addons/toggle' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { addonType, enabled } = await request.json() as any;\n\n        if (!addonType) {\n          return jsonResponse({ error: 'addon_type required' }, 400);\n        }\n\n        const timestamp = now();\n\n        // Check if addon config exists\n        const existing = await env.DB.prepare(\n          'SELECT id FROM user_addons WHERE user_id = ? AND addon_type = ?'\n        ).bind(userId, addonType).first();\n\n        if (existing) {\n          // Update existing\n          await env.DB.prepare(\n            'UPDATE user_addons SET is_enabled = ?, updated_at = ? WHERE user_id = ? AND addon_type = ?'\n          ).bind(enabled ? 1 : 0, timestamp, userId, addonType).run();\n        } else {\n          // Create new\n          await env.DB.prepare(\n            'INSERT INTO user_addons (id, user_id, addon_type, is_enabled, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)'\n          ).bind(generateId(), userId, addonType, enabled ? 1 : 0, timestamp, timestamp).run();\n        }\n\n        return jsonResponse({ message: 'Addon updated successfully', enabled });\n      }\n\n      // Get addon results for a call\n      if (url.pathname.startsWith('/api/addon-results/') && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const callId = url.pathname.split('/').pop();\n\n        const { results } = await env.DB.prepare(\n          'SELECT addon_type, status, result_data, error_message, execution_time_ms, created_at FROM addon_results WHERE call_id = ? AND user_id = ?'\n        ).bind(callId, userId).all();\n\n        return jsonResponse({ results: results || [] });\n      }\n\n      // ============================================\n      // SCHEDULING TRIGGERS ENDPOINTS (Protected)\n      // ============================================\n\n      // Get all scheduling triggers for user\n      if (url.pathname === '/api/scheduling-triggers' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { results } = await env.DB.prepare(\n          'SELECT * FROM scheduling_triggers WHERE user_id = ? ORDER BY created_at DESC'\n        ).bind(userId).all();\n\n        return jsonResponse(results || []);\n      }\n\n      // Create scheduling trigger\n      if (url.pathname === '/api/scheduling-triggers' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { name, destination_url, send_enhanced_data } = await request.json() as any;\n\n        if (!name || !destination_url) {\n          return jsonResponse({ error: 'Name and destination URL are required' }, 400);\n        }\n\n        const triggerId = generateId();\n        const timestamp = now();\n\n        await env.DB.prepare(\n          `INSERT INTO scheduling_triggers (id, user_id, name, destination_url, send_enhanced_data, is_active, created_at, updated_at)\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?)`\n        ).bind(\n          triggerId,\n          userId,\n          name,\n          destination_url,\n          send_enhanced_data ? 1 : 0,\n          1, // active by default\n          timestamp,\n          timestamp\n        ).run();\n\n        return jsonResponse({ id: triggerId, message: 'Scheduling trigger created successfully' });\n      }\n\n      // Update scheduling trigger\n      if (url.pathname.startsWith('/api/scheduling-triggers/') && request.method === 'PUT') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const triggerId = url.pathname.split('/').pop();\n        const { name, destination_url, send_enhanced_data, is_active } = await request.json() as any;\n\n        await env.DB.prepare(\n          `UPDATE scheduling_triggers\n           SET name = ?, destination_url = ?, send_enhanced_data = ?, is_active = ?, updated_at = ?\n           WHERE id = ? AND user_id = ?`\n        ).bind(\n          name,\n          destination_url,\n          send_enhanced_data ? 1 : 0,\n          is_active ? 1 : 0,\n          now(),\n          triggerId,\n          userId\n        ).run();\n\n        return jsonResponse({ message: 'Scheduling trigger updated successfully' });\n      }\n\n      // Delete scheduling trigger\n      if (url.pathname.startsWith('/api/scheduling-triggers/') && request.method === 'DELETE') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const triggerId = url.pathname.split('/').pop();\n\n        await env.DB.prepare(\n          'DELETE FROM scheduling_triggers WHERE id = ? AND user_id = ?'\n        ).bind(triggerId, userId).run();\n\n        return jsonResponse({ message: 'Scheduling trigger deleted successfully' });\n      }\n\n      // Get scheduling trigger logs\n      if (url.pathname === '/api/scheduling-trigger-logs' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const triggerId = url.searchParams.get('trigger_id');\n\n        let query = `\n          SELECT stl.*, st.name as trigger_name, wc.customer_name, wc.appointment_date, wc.appointment_time\n          FROM scheduling_trigger_logs stl\n          JOIN scheduling_triggers st ON st.id = stl.trigger_id\n          JOIN webhook_calls wc ON wc.id = stl.call_id\n          WHERE st.user_id = ?\n        `;\n\n        const params = [userId];\n\n        if (triggerId) {\n          query += ' AND stl.trigger_id = ?';\n          params.push(triggerId);\n        }\n\n        query += ' ORDER BY stl.created_at DESC LIMIT 100';\n\n        const { results } = await env.DB.prepare(query).bind(...params).all();\n\n        return jsonResponse(results || []);\n      }\n\n      // ============================================\n      // KNOWLEDGE BASE ENDPOINTS (Protected)\n      // ============================================\n\n      // List knowledge files for an agent\n      if (url.pathname.startsWith('/api/knowledge-files/') && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const agentId = url.pathname.split('/').pop();\n        \n        const { results } = await env.DB.prepare(\n          'SELECT * FROM agent_knowledge_files WHERE agent_id = ? ORDER BY created_at DESC'\n        ).bind(agentId).all();\n\n        return jsonResponse(results || []);\n      }\n\n      // Create knowledge file record\n      if (url.pathname === '/api/knowledge-files' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { agent_id, vapi_file_id, file_name, file_size, status } = await request.json() as any;\n\n        if (!agent_id || !vapi_file_id || !file_name) {\n          return jsonResponse({ error: 'Missing required fields' }, 400);\n        }\n\n        const id = generateId();\n        const timestamp = now();\n\n        await env.DB.prepare(\n          'INSERT INTO agent_knowledge_files (id, agent_id, vapi_file_id, file_name, file_size, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)'\n        ).bind(id, agent_id, vapi_file_id, file_name, file_size || 0, status || 'ready', timestamp, timestamp).run();\n\n        return jsonResponse({\n          id,\n          agent_id,\n          vapi_file_id,\n          file_name,\n          file_size: file_size || 0,\n          status: status || 'ready',\n          created_at: timestamp,\n          updated_at: timestamp\n        }, 201);\n      }\n\n      // Delete knowledge file record\n      if (url.pathname.startsWith('/api/knowledge-files/') && request.method === 'DELETE') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const id = url.pathname.split('/').pop();\n\n        await env.DB.prepare(\n          'DELETE FROM agent_knowledge_files WHERE id = ?'\n        ).bind(id).run();\n\n        return jsonResponse({ message: 'File deleted successfully' });\n      }\n\n      // ============================================\n      // WEBHOOK ENDPOINTS\n      // ============================================\n\n      // Create new webhook\n      if (url.pathname === '/api/webhooks' && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const { name } = await request.json() as any;\n\n        if (!name) {\n          return jsonResponse({ error: 'Webhook name required' }, 400);\n        }\n\n        // Generate unique webhook ID\n        const webhookId = 'wh_' + generateId();\n        const webhookUrl = `https://api.voice-config.channelautomation.com/webhook/${webhookId}`;\n        const timestamp = now();\n\n        await env.DB.prepare(\n          'INSERT INTO webhooks (id, user_id, webhook_url, name, is_active, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)'\n        ).bind(webhookId, userId, webhookUrl, name, 1, timestamp, timestamp).run();\n\n        return jsonResponse({\n          id: webhookId,\n          url: webhookUrl,\n          name,\n          is_active: true,\n          created_at: timestamp\n        }, 201);\n      }\n\n      // List webhooks for user (supports workspace context)\n      if (url.pathname === '/api/webhooks' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        const { results } = await env.DB.prepare(\n          `SELECT\n            w.id,\n            w.webhook_url,\n            w.name,\n            w.is_active,\n            w.created_at,\n            COUNT(wc.id) as call_count\n          FROM webhooks w\n          LEFT JOIN webhook_calls wc ON w.id = wc.webhook_id\n          WHERE w.user_id = ?\n          GROUP BY w.id\n          ORDER BY w.created_at DESC`\n        ).bind(effectiveUserId).all();\n\n        return jsonResponse(results || []);\n      }\n\n      // Delete webhook\n      if (url.pathname.startsWith('/api/webhooks/') && request.method === 'DELETE') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const webhookId = url.pathname.split('/').pop();\n\n        // Verify ownership\n        const webhook = await env.DB.prepare(\n          'SELECT user_id FROM webhooks WHERE id = ?'\n        ).bind(webhookId).first() as any;\n\n        if (!webhook) {\n          return jsonResponse({ error: 'Webhook not found' }, 404);\n        }\n\n        if (webhook.user_id !== userId) {\n          return jsonResponse({ error: 'Forbidden' }, 403);\n        }\n\n        // Delete webhook (cascade will delete calls and logs)\n        await env.DB.prepare(\n          'DELETE FROM webhooks WHERE id = ?'\n        ).bind(webhookId).run();\n\n        return jsonResponse({ message: 'Webhook deleted successfully' });\n      }\n\n      // Get webhook calls (with KV caching, supports workspace context)\n      if (url.pathname === '/api/webhook-calls' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        const webhookId = url.searchParams.get('webhook_id');\n        const limit = parseInt(url.searchParams.get('limit') || '100');\n        const offset = parseInt(url.searchParams.get('offset') || '0');\n        const page = Math.floor(offset / limit) + 1;\n\n        // Initialize cache\n        const cache = new VoiceAICache(env.CACHE);\n        \n        // Check if cache-busting parameter is present\n        const cacheBust = url.searchParams.get('_t');\n\n        // Try to get from cache first (only if no webhook filter, reasonable page size, and no cache-bust)\n        // Use effectiveUserId for cache key to scope by workspace owner\n        if (!webhookId && limit <= 100 && !cacheBust) {\n          const cached = await cache.getCachedRecordings(effectiveUserId, page, limit);\n          if (cached) {\n            console.log(`Cache HIT for recordings: user=${effectiveUserId}, page=${page}, limit=${limit}`);\n            return jsonResponse(cached);\n          }\n        }\n\n        console.log(`Cache MISS for recordings: user=${effectiveUserId}, page=${page}, limit=${limit}${cacheBust ? ' (cache-bust requested)' : ''}`);\n\n        // Fetch from database with enhanced data (using effectiveUserId for workspace context)\n        let query = env.DB.prepare(\n          `SELECT\n            wc.id,\n            wc.webhook_id,\n            wc.vapi_call_id,\n            wc.phone_number,\n            wc.customer_number,\n            wc.recording_url,\n            wc.ended_reason,\n            wc.summary,\n            wc.structured_data,\n            wc.raw_payload,\n            wc.intent,\n            wc.sentiment,\n            wc.outcome,\n            wc.analysis_completed,\n            wc.analyzed_at,\n            wc.customer_name,\n            wc.caller_name,\n            wc.caller_type,\n            wc.carrier_name,\n            wc.line_type,\n            wc.created_at,\n            wc.duration_seconds,\n            ar.result_data as enhanced_data\n          FROM webhook_calls wc\n          LEFT JOIN addon_results ar ON ar.call_id = wc.id AND ar.addon_type = 'enhanced_data' AND ar.status = 'success'\n          WHERE wc.user_id = ?\n          ${webhookId ? 'AND wc.webhook_id = ?' : ''}\n          ORDER BY CASE \n            WHEN wc.created_at > 1000000000000 THEN wc.created_at / 1000 \n            ELSE wc.created_at \n          END DESC\n          LIMIT ? OFFSET ?`\n        );\n\n        const params = webhookId\n          ? [effectiveUserId, webhookId, limit, offset]\n          : [effectiveUserId, limit, offset];\n\n        const { results } = await query.bind(...params).all();\n\n        // Parse structured_data, raw_payload, and enhanced_data JSON for each result\n        const parsedResults = (results || []).map((row: any) => ({\n          ...row,\n          structured_data: row.structured_data ? JSON.parse(row.structured_data) : null,\n          raw_payload: row.raw_payload ? JSON.parse(row.raw_payload) : null,\n          enhanced_data: row.enhanced_data ? JSON.parse(row.enhanced_data) : null\n        }));\n\n        // Cache the results (only if no webhook filter and reasonable page size)\n        // Use effectiveUserId for cache key to scope by workspace owner\n        if (!webhookId && limit <= 100) {\n          await cache.cacheRecordings(effectiveUserId, parsedResults, page, limit, CACHE_TTL.RECORDINGS);\n        }\n\n        return jsonResponse(parsedResults);\n      }\n\n      // Get intent analysis with caching\n      // Get active calls\n      // Get active calls (supports workspace context)\n      if (url.pathname === '/api/active-calls' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        // Fetch active calls from database (using effectiveUserId)\n        const { results } = await env.DB.prepare(\n          `SELECT\n            id,\n            vapi_call_id,\n            customer_number,\n            caller_name,\n            carrier_name,\n            line_type,\n            status,\n            started_at,\n            updated_at\n          FROM active_calls\n          WHERE user_id = ?\n          ORDER BY started_at DESC`\n        ).bind(effectiveUserId).all();\n\n        return jsonResponse(results);\n      }\n\n      // Get concurrent calls stats\n      // Get concurrent calls stats (supports workspace context)\n      if (url.pathname === '/api/concurrent-calls' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        // Get current concurrent calls (active calls)\n        const activeCallsResult = await env.DB.prepare(\n          `SELECT COUNT(*) as count FROM active_calls WHERE user_id = ?`\n        ).bind(effectiveUserId).first() as any;\n        \n        const currentConcurrent = activeCallsResult?.count || 0;\n\n        // Get historical peak concurrent calls\n        // We'll analyze webhook_calls to find the maximum number of overlapping calls\n        const { results } = await env.DB.prepare(\n          `SELECT raw_payload, created_at\n          FROM webhook_calls\n          WHERE user_id = ?\n          AND raw_payload IS NOT NULL\n          ORDER BY created_at DESC\n          LIMIT 1000`\n        ).bind(effectiveUserId).all();\n\n        let peakConcurrent = 0;\n        \n        if (results && results.length > 0) {\n          // Extract call time ranges from raw_payload\n          const callRanges: Array<{ start: number; end: number }> = [];\n          \n          for (const row of results as any[]) {\n            try {\n              const payload = typeof row.raw_payload === 'string' \n                ? JSON.parse(row.raw_payload) \n                : row.raw_payload;\n              \n              const startedAt = payload.message?.call?.startedAt;\n              const endedAt = payload.message?.call?.endedAt;\n              \n              if (startedAt && endedAt) {\n                const startTime = new Date(startedAt).getTime();\n                const endTime = new Date(endedAt).getTime();\n                if (startTime && endTime && startTime < endTime) {\n                  callRanges.push({ start: startTime, end: endTime });\n                }\n              }\n            } catch (error) {\n              // Skip invalid payloads\n              continue;\n            }\n          }\n\n          // Find peak concurrent calls by checking all time points\n          if (callRanges.length > 0) {\n            // Collect all unique time points (start and end times)\n            const timePoints = new Set<number>();\n            callRanges.forEach(range => {\n              timePoints.add(range.start);\n              timePoints.add(range.end);\n            });\n\n            // Check concurrent calls at each time point\n            const sortedTimePoints = Array.from(timePoints).sort((a, b) => a - b);\n            \n            for (const timePoint of sortedTimePoints) {\n              const concurrent = callRanges.filter(range => \n                range.start <= timePoint && range.end > timePoint\n              ).length;\n              \n              if (concurrent > peakConcurrent) {\n                peakConcurrent = concurrent;\n              }\n            }\n          }\n        }\n\n        return jsonResponse({\n          current: currentConcurrent,\n          peak: peakConcurrent\n        });\n      }\n\n      // Get concurrent calls time-series data\n      // Get concurrent calls timeseries (supports workspace context)\n      if (url.pathname === '/api/concurrent-calls/timeseries' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        const granularity = url.searchParams.get('granularity') || 'minute'; // minute, hour, day\n        const limit = parseInt(url.searchParams.get('limit') || '1000');\n\n        // Fetch recent calls with their time ranges (using effectiveUserId)\n        const { results } = await env.DB.prepare(\n          `SELECT raw_payload, created_at\n          FROM webhook_calls\n          WHERE user_id = ?\n          AND raw_payload IS NOT NULL\n          ORDER BY created_at DESC\n          LIMIT ?`\n        ).bind(effectiveUserId, limit).all();\n\n        if (!results || results.length === 0) {\n          return jsonResponse({ data: [], labels: [] });\n        }\n\n        // Extract call time ranges\n        const callRanges: Array<{ start: number; end: number }> = [];\n        \n        for (const row of results as any[]) {\n          try {\n            const payload = typeof row.raw_payload === 'string' \n              ? JSON.parse(row.raw_payload) \n              : row.raw_payload;\n            \n            const startedAt = payload.message?.call?.startedAt;\n            const endedAt = payload.message?.call?.endedAt;\n            \n            if (startedAt && endedAt) {\n              const startTime = new Date(startedAt).getTime();\n              const endTime = new Date(endedAt).getTime();\n              if (startTime && endTime && startTime < endTime) {\n                callRanges.push({ start: startTime, end: endTime });\n              }\n            }\n          } catch (error) {\n            continue;\n          }\n        }\n\n        if (callRanges.length === 0) {\n          return jsonResponse({ data: [], labels: [] });\n        }\n\n        // Determine time window\n        const allTimes = callRanges.flatMap(r => [r.start, r.end]);\n        const minTime = Math.min(...allTimes);\n        const maxTime = Math.max(...allTimes);\n\n        // Calculate time buckets based on granularity\n        let bucketSize: number;\n        let dateFormatter: (date: Date) => string;\n\n        if (granularity === 'minute') {\n          bucketSize = 60 * 1000; // 1 minute\n          dateFormatter = (d) => d.toISOString().slice(0, 16).replace('T', ' ');\n        } else if (granularity === 'hour') {\n          bucketSize = 60 * 60 * 1000; // 1 hour\n          dateFormatter = (d) => d.toISOString().slice(0, 13) + ':00';\n        } else { // day\n          bucketSize = 24 * 60 * 60 * 1000; // 1 day\n          dateFormatter = (d) => d.toISOString().split('T')[0];\n        }\n\n        // Create time buckets\n        const buckets = new Map<string, number>();\n        const bucketCount = Math.ceil((maxTime - minTime) / bucketSize);\n        \n        for (let i = 0; i <= bucketCount; i++) {\n          const bucketTime = minTime + (i * bucketSize);\n          const bucketKey = dateFormatter(new Date(bucketTime));\n          buckets.set(bucketKey, 0);\n        }\n\n        // Count concurrent calls at each bucket's midpoint\n        for (let i = 0; i <= bucketCount; i++) {\n          const bucketTime = minTime + (i * bucketSize);\n          const midpoint = bucketTime + (bucketSize / 2);\n          const concurrent = callRanges.filter(range => \n            range.start <= midpoint && range.end > midpoint\n          ).length;\n          \n          const bucketKey = dateFormatter(new Date(bucketTime));\n          buckets.set(bucketKey, concurrent);\n        }\n\n        // Convert to arrays\n        const labels = Array.from(buckets.keys());\n        const data = Array.from(buckets.values());\n\n        return jsonResponse({ data, labels });\n      }\n\n      // Get reason call ended data\n      // Get call ended reasons (supports workspace context)\n      if (url.pathname === '/api/call-ended-reasons' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        const startDate = url.searchParams.get('start_date');\n        const endDate = url.searchParams.get('end_date');\n\n        // Build query with optional date filtering\n        // Filter out rows where created_at is null or ended_reason is null\n        let queryStr = `SELECT \n          ended_reason,\n          DATE(datetime(created_at, 'unixepoch')) as call_date,\n          COUNT(*) as count\n        FROM webhook_calls\n        WHERE user_id = ?\n        AND ended_reason IS NOT NULL\n        AND created_at IS NOT NULL`;\n        \n        const params: any[] = [effectiveUserId];\n        \n        if (startDate) {\n          queryStr += ` AND DATE(datetime(created_at, 'unixepoch')) >= ?`;\n          params.push(startDate);\n        }\n        if (endDate) {\n          queryStr += ` AND DATE(datetime(created_at, 'unixepoch')) <= ?`;\n          params.push(endDate);\n        }\n        \n        queryStr += ` GROUP BY ended_reason, call_date ORDER BY call_date DESC, count DESC`;\n\n        const { results } = await env.DB.prepare(queryStr).bind(...params).all();\n\n        if (!results || results.length === 0) {\n          return jsonResponse({ dates: [], reasons: {}, colors: {} });\n        }\n\n        // Group data by date and reason\n        const dateSet = new Set<string>();\n        const reasonsSet = new Set<string>();\n        const dataMap = new Map<string, Map<string, number>>(); // date -> reason -> count\n\n        for (const row of results as any[]) {\n          const date = row.call_date;\n          const reason = row.ended_reason || 'unknown';\n          const count = row.count || 0;\n\n          dateSet.add(date);\n          reasonsSet.add(reason);\n\n          if (!dataMap.has(date)) {\n            dataMap.set(date, new Map());\n          }\n          dataMap.get(date)!.set(reason, count);\n        }\n\n        // Sort dates\n        const dates = Array.from(dateSet).sort();\n\n        // Create reason mapping with colors\n        const reasons = Array.from(reasonsSet);\n        const reasonColors: Record<string, string> = {};\n        const colorPalette = [\n          '#8b5cf6', // purple\n          '#3b82f6', // blue\n          '#10b981', // green\n          '#f59e0b', // amber\n          '#ef4444', // red\n          '#06b6d4', // cyan\n          '#ec4899', // pink\n          '#6366f1', // indigo\n        ];\n\n        reasons.forEach((reason, idx) => {\n          reasonColors[reason] = colorPalette[idx % colorPalette.length];\n        });\n\n        // Build the data structure\n        const reasonData: Record<string, number[]> = {};\n        reasons.forEach(reason => {\n          reasonData[reason] = dates.map(date => {\n            const dateData = dataMap.get(date);\n            return dateData?.get(reason) || 0;\n          });\n        });\n\n        return jsonResponse({\n          dates,\n          reasons: reasonData,\n          colors: reasonColors\n        });\n      }\n\n      // ============================================\n      // UNIFIED DASHBOARD METRICS ENDPOINT\n      // ============================================\n      // Get all dashboard data in a single optimized request\n      if (url.pathname === '/api/dashboard-metrics' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        // Parse query parameters\n        const granularity = url.searchParams.get('granularity') || 'minute';\n        const limit = parseInt(url.searchParams.get('limit') || '1000');\n        const startDate = url.searchParams.get('start_date');\n        const endDate = url.searchParams.get('end_date');\n\n        // Fetch all data in parallel for maximum performance\n        const [\n          webhookCallsResult,\n          keywordsResult,\n          concurrentCallsResult,\n          callEndedReasonsResult\n        ] = await Promise.all([\n          // 1. Fetch webhook calls with enhanced data\n          env.DB.prepare(\n            `SELECT\n              wc.id,\n              wc.webhook_id,\n              wc.vapi_call_id,\n              wc.phone_number,\n              wc.customer_number,\n              wc.recording_url,\n              wc.ended_reason,\n              wc.summary,\n              wc.structured_data,\n              wc.raw_payload,\n              wc.intent,\n              wc.sentiment,\n              wc.outcome,\n              wc.customer_name,\n              wc.caller_name,\n              wc.caller_type,\n              wc.carrier_name,\n              wc.line_type,\n              wc.created_at,\n              wc.duration_seconds,\n              ar.result_data as enhanced_data\n            FROM webhook_calls wc\n            LEFT JOIN addon_results ar ON ar.call_id = wc.id AND ar.addon_type = 'enhanced_data' AND ar.status = 'success'\n            WHERE wc.user_id = ?\n            ORDER BY CASE\n              WHEN wc.created_at > 1000000000000 THEN wc.created_at / 1000\n              ELSE wc.created_at\n            END DESC\n            LIMIT ?`\n          ).bind(effectiveUserId, limit).all(),\n\n          // 2. Fetch top keywords\n          env.DB.prepare(\n            `SELECT\n              keyword,\n              count,\n              positive_count,\n              neutral_count,\n              negative_count,\n              avg_sentiment,\n              last_detected_at\n            FROM call_keywords\n            WHERE user_id = ?\n            ORDER BY count DESC\n            LIMIT 20`\n          ).bind(effectiveUserId).all(),\n\n          // 3. Fetch active calls for concurrent count\n          env.DB.prepare(\n            `SELECT COUNT(*) as count FROM active_calls WHERE user_id = ?`\n          ).bind(effectiveUserId).first(),\n\n          // 4. Fetch call ended reasons\n          (async () => {\n            let queryStr = `SELECT\n              ended_reason,\n              DATE(datetime(created_at, 'unixepoch')) as call_date,\n              COUNT(*) as count\n            FROM webhook_calls\n            WHERE user_id = ?\n            AND ended_reason IS NOT NULL\n            AND created_at IS NOT NULL`;\n\n            const params: any[] = [effectiveUserId];\n\n            if (startDate) {\n              queryStr += ` AND DATE(datetime(created_at, 'unixepoch')) >= ?`;\n              params.push(startDate);\n            }\n            if (endDate) {\n              queryStr += ` AND DATE(datetime(created_at, 'unixepoch')) <= ?`;\n              params.push(endDate);\n            }\n\n            queryStr += ` GROUP BY ended_reason, call_date ORDER BY call_date DESC, count DESC`;\n\n            return env.DB.prepare(queryStr).bind(...params).all();\n          })()\n        ]);\n\n        // Parse webhook calls results\n        const webhookCalls = (webhookCallsResult.results || []).map((row: any) => ({\n          ...row,\n          structured_data: row.structured_data ? JSON.parse(row.structured_data) : null,\n          raw_payload: row.raw_payload ? JSON.parse(row.raw_payload) : null,\n          enhanced_data: row.enhanced_data ? JSON.parse(row.enhanced_data) : null\n        }));\n\n        // Calculate server-side metrics from webhook calls\n        const totalCalls = webhookCalls.length;\n        const answeredCalls = webhookCalls.filter((c: any) => c.recording_url).length;\n        const unansweredCalls = totalCalls - answeredCalls;\n        const answerRate = totalCalls > 0 ? (answeredCalls / totalCalls) * 100 : 0;\n\n        const qualifiedLeadsCount = webhookCalls.filter((c: any) => c.outcome === 'Successful').length;\n        const qualificationRate = answeredCalls > 0 ? (qualifiedLeadsCount / answeredCalls) * 100 : 0;\n\n        const appointmentsDetected = webhookCalls.filter((c: any) => c.intent === 'Scheduling').length;\n        const appointmentDetectionRate = answeredCalls > 0 ? (appointmentsDetected / answeredCalls) * 100 : 0;\n\n        // Calculate average handling time from duration_seconds\n        const callsWithDuration = webhookCalls.filter((c: any) => c.recording_url && c.duration_seconds);\n        const avgHandlingTime = callsWithDuration.length > 0\n          ? callsWithDuration.reduce((sum: number, c: any) => sum + (c.duration_seconds || 0), 0) / callsWithDuration.length\n          : 0;\n\n        // Calculate total call minutes\n        const totalCallMinutes = Math.floor(\n          webhookCalls.reduce((sum: number, c: any) => sum + (c.duration_seconds || 0), 0) / 60\n        );\n\n        // Calculate average summary length\n        const callsWithSummary = webhookCalls.filter((c: any) => c.summary && c.summary.length > 0);\n        const avgSummaryLength = callsWithSummary.length > 0\n          ? callsWithSummary.reduce((sum: number, c: any) => sum + c.summary.length, 0) / callsWithSummary.length\n          : 0;\n\n        // Calculate sentiment breakdown\n        const positiveCalls = webhookCalls.filter((c: any) => c.sentiment === 'Positive').length;\n        const negativeCalls = webhookCalls.filter((c: any) => c.sentiment === 'Negative').length;\n        const neutralCalls = totalCalls - positiveCalls - negativeCalls;\n\n        const sentimentData = [\n          { label: 'Positive', value: positiveCalls, color: '#10b981' },\n          { label: 'Neutral', value: neutralCalls, color: '#3b82f6' },\n          { label: 'Negative', value: negativeCalls, color: '#ef4444' }\n        ];\n\n        // Process concurrent calls data\n        const currentConcurrent = (concurrentCallsResult as any)?.count || 0;\n\n        // Calculate peak concurrent calls from webhook calls\n        let peakConcurrent = 0;\n        const callRanges: Array<{ start: number; end: number }> = [];\n\n        for (const call of webhookCalls as any[]) {\n          try {\n            const payload = call.raw_payload;\n            const startedAt = payload?.message?.call?.startedAt || payload?.message?.startedAt;\n            const endedAt = payload?.message?.call?.endedAt || payload?.message?.endedAt;\n\n            if (startedAt && endedAt) {\n              const startTime = new Date(startedAt).getTime();\n              const endTime = new Date(endedAt).getTime();\n              if (startTime && endTime && startTime < endTime) {\n                callRanges.push({ start: startTime, end: endTime });\n              }\n            }\n          } catch (error) {\n            continue;\n          }\n        }\n\n        // Find peak concurrent calls\n        if (callRanges.length > 0) {\n          const timePoints = new Set<number>();\n          callRanges.forEach(range => {\n            timePoints.add(range.start);\n            timePoints.add(range.end);\n          });\n\n          const sortedTimePoints = Array.from(timePoints).sort((a, b) => a - b);\n\n          for (const timePoint of sortedTimePoints) {\n            const concurrent = callRanges.filter(range =>\n              range.start <= timePoint && range.end > timePoint\n            ).length;\n\n            if (concurrent > peakConcurrent) {\n              peakConcurrent = concurrent;\n            }\n          }\n        }\n\n        // Calculate concurrent calls time-series\n        let concurrentTimeSeries = { data: [] as number[], labels: [] as string[] };\n\n        if (callRanges.length > 0) {\n          const allTimes = callRanges.flatMap(r => [r.start, r.end]);\n          const minTime = Math.min(...allTimes);\n          const maxTime = Math.max(...allTimes);\n\n          let bucketSize: number;\n          let dateFormatter: (date: Date) => string;\n\n          if (granularity === 'day') {\n            bucketSize = 24 * 60 * 60 * 1000;\n            dateFormatter = (date: Date) => date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n          } else if (granularity === 'hour') {\n            bucketSize = 60 * 60 * 1000;\n            dateFormatter = (date: Date) => date.toLocaleTimeString('en-US', { month: 'short', day: 'numeric', hour: 'numeric' });\n          } else {\n            bucketSize = 60 * 1000;\n            dateFormatter = (date: Date) => date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });\n          }\n\n          const buckets = new Map<number, number>();\n          const bucketStart = Math.floor(minTime / bucketSize) * bucketSize;\n          const bucketEnd = Math.ceil(maxTime / bucketSize) * bucketSize;\n\n          for (let bucket = bucketStart; bucket <= bucketEnd; bucket += bucketSize) {\n            const bucketMidpoint = bucket + bucketSize / 2;\n            const concurrentAtBucket = callRanges.filter(range =>\n              range.start <= bucketMidpoint && range.end > bucketMidpoint\n            ).length;\n            buckets.set(bucket, concurrentAtBucket);\n          }\n\n          const sortedBuckets = Array.from(buckets.entries()).sort((a, b) => a[0] - b[0]);\n          concurrentTimeSeries = {\n            data: sortedBuckets.map(([_, count]) => count),\n            labels: sortedBuckets.map(([time, _]) => dateFormatter(new Date(time)))\n          };\n        }\n\n        // Process call ended reasons\n        const callEndedResults = callEndedReasonsResult.results || [];\n        let callEndedReasons = { dates: [] as string[], reasons: {} as Record<string, number[]>, colors: {} as Record<string, string> };\n\n        if (callEndedResults.length > 0) {\n          const dateSet = new Set<string>();\n          const reasonsSet = new Set<string>();\n          const dataMap = new Map<string, Map<string, number>>();\n\n          for (const row of callEndedResults as any[]) {\n            const date = row.call_date;\n            const reason = row.ended_reason || 'unknown';\n            const count = row.count || 0;\n\n            dateSet.add(date);\n            reasonsSet.add(reason);\n\n            if (!dataMap.has(date)) {\n              dataMap.set(date, new Map());\n            }\n            dataMap.get(date)!.set(reason, count);\n          }\n\n          const dates = Array.from(dateSet).sort();\n          const reasons = Array.from(reasonsSet);\n          const reasonColors: Record<string, string> = {};\n          const colorPalette = [\n            '#8b5cf6', '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#06b6d4', '#ec4899', '#6366f1'\n          ];\n\n          reasons.forEach((reason, idx) => {\n            reasonColors[reason] = colorPalette[idx % colorPalette.length];\n          });\n\n          const reasonData: Record<string, number[]> = {};\n          reasons.forEach(reason => {\n            reasonData[reason] = dates.map(date => {\n              const dateData = dataMap.get(date);\n              return dateData?.get(reason) || 0;\n            });\n          });\n\n          callEndedReasons = { dates, reasons: reasonData, colors: reasonColors };\n        }\n\n        // Return unified dashboard response\n        return jsonResponse({\n          metrics: {\n            totalCalls,\n            answeredCalls,\n            unansweredCalls,\n            answerRate,\n            spanishCallsPercent: 0,\n            englishCallsPercent: 100,\n            avgSummaryLength,\n            qualifiedLeadsCount,\n            qualificationRate,\n            appointmentDetectionRate,\n            crmSuccessRate: totalCallMinutes,\n            avgSentiment: 0,\n            avgHandlingTime,\n            automationRate: answerRate\n          },\n          calls: webhookCalls,\n          keywords: keywordsResult.results || [],\n          sentimentData,\n          concurrent: {\n            current: currentConcurrent,\n            peak: peakConcurrent\n          },\n          concurrentTimeSeries,\n          callEndedReasons\n        });\n      }\n\n      // Get top keywords\n      // Get top keywords with sentiment (supports workspace context)\n      if (url.pathname === '/api/keywords' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        // Fetch top keywords from database with sentiment data (limit to top 20 for heat map)\n        const { results } = await env.DB.prepare(\n          `SELECT\n            keyword,\n            count,\n            positive_count,\n            neutral_count,\n            negative_count,\n            avg_sentiment,\n            last_detected_at\n          FROM call_keywords\n          WHERE user_id = ?\n          ORDER BY count DESC\n          LIMIT 20`\n        ).bind(effectiveUserId).all();\n\n        return jsonResponse(results);\n      }\n\n      // End active call\n      if (url.pathname.startsWith('/api/calls/') && url.pathname.endsWith('/end') && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const callId = url.pathname.split('/')[3];\n\n        console.log('[Call Control] End call request received:', {\n          callId,\n          userId\n        });\n\n        // Get workspace settings (uses helper function with fallback to user_settings)\n        const settings = await getWorkspaceSettingsForUser(env, userId);\n\n        if (!settings?.private_key) {\n          console.log('[Call Control] VAPI credentials not configured for user:', userId);\n          return jsonResponse({ error: 'VAPI credentials not configured' }, 400);\n        }\n\n        // Call VAPI API to end the call\n        try {\n          // Step 1: Get the call details to retrieve controlUrl\n          console.log('[Call Control] Fetching call details for controlUrl:', callId);\n\n          const getCallResponse = await fetch(`https://api.vapi.ai/call/${callId}`, {\n            method: 'GET',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`\n            }\n          });\n\n          if (!getCallResponse.ok) {\n            const error = await getCallResponse.text();\n            console.error('[Call Control] Failed to get call details:', {\n              callId,\n              status: getCallResponse.status,\n              error\n            });\n            return jsonResponse({ error: 'Failed to get call details' }, getCallResponse.status);\n          }\n\n          const callDetails = await getCallResponse.json() as any;\n          const controlUrl = callDetails.monitor?.controlUrl;\n\n          console.log('[Call Control] Call details retrieved:', {\n            callId,\n            hasControlUrl: !!controlUrl\n          });\n\n          if (!controlUrl) {\n            console.error('[Call Control] No controlUrl found in call details');\n            return jsonResponse({ error: 'Call control URL not available' }, 400);\n          }\n\n          // Step 2: Send end-call command to controlUrl\n          const endCallPayload = {\n            type: 'end-call'\n          };\n\n          console.log('[Call Control] Sending end-call command to controlUrl:', {\n            callId,\n            payload: endCallPayload\n          });\n\n          const endCallResponse = await fetch(controlUrl, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(endCallPayload)\n          });\n\n          if (!endCallResponse.ok) {\n            const error = await endCallResponse.text();\n            console.error('[Call Control] End-call command failed:', {\n              callId,\n              status: endCallResponse.status,\n              error\n            });\n            return jsonResponse({ error: 'Failed to end call' }, endCallResponse.status);\n          }\n\n          console.log('[Call Control] Call ended successfully:', callId);\n\n          return jsonResponse({ success: true, message: 'Call ended successfully' });\n        } catch (error) {\n          console.error('[Call Control] Error ending call:', {\n            callId,\n            error: error instanceof Error ? error.message : String(error)\n          });\n          return jsonResponse({ error: 'Failed to end call' }, 500);\n        }\n      }\n\n      // Transfer active call\n      if (url.pathname.startsWith('/api/calls/') && url.pathname.endsWith('/transfer') && request.method === 'POST') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const callId = url.pathname.split('/')[3];\n        const body = await request.json() as any;\n        const transferNumber = body.phoneNumber;\n\n        console.log('[Call Control] Transfer call request received:', {\n          callId,\n          userId,\n          transferNumber\n        });\n\n        if (!transferNumber) {\n          console.log('[Call Control] Transfer number missing');\n          return jsonResponse({ error: 'Transfer phone number required' }, 400);\n        }\n\n        // Get workspace VAPI credentials (with fallback to user_settings for migration)\n        const settings = await getWorkspaceSettingsForUser(env, userId);\n\n        if (!settings?.private_key) {\n          console.log('[Call Control] VAPI credentials not configured for user:', userId);\n          return jsonResponse({ error: 'VAPI credentials not configured' }, 400);\n        }\n\n        // Call VAPI API to transfer the call\n        try {\n          // Step 1: Get the call details to retrieve controlUrl\n          console.log('[Call Control] Fetching call details for controlUrl:', callId);\n\n          const getCallResponse = await fetch(`https://api.vapi.ai/call/${callId}`, {\n            method: 'GET',\n            headers: {\n              'Authorization': `Bearer ${settings.private_key}`\n            }\n          });\n\n          if (!getCallResponse.ok) {\n            const error = await getCallResponse.text();\n            console.error('[Call Control] Failed to get call details:', {\n              callId,\n              status: getCallResponse.status,\n              error\n            });\n            return jsonResponse({ error: 'Failed to get call details' }, getCallResponse.status);\n          }\n\n          const callDetails = await getCallResponse.json() as any;\n          const controlUrl = callDetails.monitor?.controlUrl;\n\n          console.log('[Call Control] Call details retrieved:', {\n            callId,\n            hasControlUrl: !!controlUrl\n          });\n\n          if (!controlUrl) {\n            console.error('[Call Control] No controlUrl found in call details');\n            return jsonResponse({ error: 'Call control URL not available' }, 400);\n          }\n\n          // Step 2: Send transfer command to controlUrl\n          const transferPayload = {\n            type: 'transfer',\n            destination: {\n              type: 'number',\n              number: transferNumber\n            }\n          };\n\n          console.log('[Call Control] Sending transfer command to controlUrl:', {\n            callId,\n            transferNumber,\n            payload: transferPayload\n          });\n\n          const transferResponse = await fetch(controlUrl, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(transferPayload)\n          });\n\n          if (!transferResponse.ok) {\n            const error = await transferResponse.text();\n            console.error('[Call Control] Transfer command failed:', {\n              callId,\n              transferNumber,\n              status: transferResponse.status,\n              error\n            });\n            return jsonResponse({ error: 'Failed to transfer call' }, transferResponse.status);\n          }\n\n          console.log('[Call Control] Call transferred successfully:', {\n            callId,\n            transferNumber\n          });\n\n          return jsonResponse({ success: true, message: 'Call transferred successfully' });\n        } catch (error) {\n          console.error('[Call Control] Error transferring call:', {\n            callId,\n            transferNumber,\n            error: error instanceof Error ? error.message : String(error)\n          });\n          return jsonResponse({ error: 'Failed to transfer call' }, 500);\n        }\n      }\n\n      // Get intent analysis (supports workspace context)\n      if (url.pathname === '/api/intent-analysis' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Get effective user ID for workspace context\n        const { effectiveUserId } = await getEffectiveUserId(env, userId);\n\n        const limit = parseInt(url.searchParams.get('limit') || '100');\n        const offset = parseInt(url.searchParams.get('offset') || '0');\n        const page = Math.floor(offset / limit) + 1;\n\n        // Initialize cache\n        const cache = new VoiceAICache(env.CACHE);\n\n        // Try to get from cache first (use effectiveUserId for cache key)\n        if (limit <= 100) {\n          const cached = await cache.getCachedIntentSummary(effectiveUserId);\n          if (cached) {\n            console.log(`Cache HIT for intent analysis: user=${effectiveUserId}`);\n            return jsonResponse(cached);\n          }\n        }\n\n        console.log(`Cache MISS for intent analysis: user=${effectiveUserId}`);\n\n        // Fetch analyzed calls from database with enhanced data (using effectiveUserId)\n        const { results } = await env.DB.prepare(\n          `SELECT\n            wc.id,\n            wc.webhook_id,\n            wc.vapi_call_id,\n            wc.phone_number,\n            wc.customer_number,\n            wc.recording_url,\n            wc.ended_reason,\n            wc.summary,\n            wc.structured_data,\n            wc.raw_payload,\n            wc.intent,\n            wc.sentiment,\n            wc.outcome,\n            wc.analysis_completed,\n            wc.analyzed_at,\n            wc.customer_name,\n            wc.customer_email,\n            wc.appointment_date,\n            wc.appointment_time,\n            wc.appointment_type,\n            wc.appointment_notes,\n            wc.created_at,\n            ar.result_data as enhanced_data\n          FROM webhook_calls wc\n          LEFT JOIN addon_results ar ON ar.call_id = wc.id AND ar.addon_type = 'enhanced_data' AND ar.status = 'success'\n          WHERE wc.user_id = ? AND wc.analysis_completed = 1\n          ORDER BY wc.created_at DESC\n          LIMIT ? OFFSET ?`\n        ).bind(effectiveUserId, limit, offset).all();\n\n        // Get user email for demo data check\n        const userEmail = await env.DB.prepare(\n          'SELECT email FROM users WHERE id = ?'\n        ).bind(userId).first() as any;\n\n        // Helper function to generate mock enhanced data for demo\n        const generateMockEnhancedData = (index: number) => {\n          const mockProfiles = [\n            {\n              firstName: 'Sarah',\n              lastName: 'Johnson',\n              address: '4532 Maple Avenue',\n              city: 'San Francisco',\n              state: 'CA',\n              zip: '94102',\n              countyName: 'San Francisco',\n              gender: 'F',\n              age: 42,\n              phones: [{\n                phone: 4155551234,\n                carrier: 'AT&T Mobility',\n                phoneType: 1,\n                workPhone: false,\n                activityStatus: 'Active',\n                contactabilityScore: 'High'\n              }],\n              data: {\n                addressType: 'Single Family',\n                incomeLevel: '$75K-$100K',\n                creditRange: '720-780',\n                householdIncome: '$85,000-$95,000',\n                homeOwnership: 'Owner',\n                homePrice: 875000,\n                homeValue: 920000,\n                age: 42\n              },\n              properties: [{\n                propertyType: 'Single Family Residence',\n                value: 920000,\n                estimatedValue: 920000,\n                yearBuilt: 1998,\n                bedrooms: '3',\n                rooms: '7',\n                saleDate: '2019-05-15',\n                saleAmount: 785000\n              }]\n            },\n            {\n              firstName: 'Michael',\n              lastName: 'Rodriguez',\n              address: '1847 Oak Street',\n              city: 'Portland',\n              state: 'OR',\n              zip: '97201',\n              countyName: 'Multnomah',\n              gender: 'M',\n              age: 35,\n              phones: [{\n                phone: 5035559876,\n                carrier: 'Verizon',\n                phoneType: 1,\n                workPhone: false,\n                activityStatus: 'Active',\n                contactabilityScore: 'Medium'\n              }],\n              data: {\n                addressType: 'Condominium',\n                incomeLevel: '$100K-$150K',\n                creditRange: '680-720',\n                householdIncome: '$110,000-$125,000',\n                homeOwnership: 'Owner',\n                homePrice: 425000,\n                homeValue: 465000,\n                age: 35\n              },\n              properties: [{\n                propertyType: 'Condominium',\n                value: 465000,\n                estimatedValue: 465000,\n                yearBuilt: 2015,\n                bedrooms: '2',\n                rooms: '5',\n                saleDate: '2021-03-22',\n                saleAmount: 410000\n              }]\n            },\n            {\n              firstName: 'Jennifer',\n              lastName: 'Chen',\n              address: '2315 Pine Ridge Drive',\n              city: 'Seattle',\n              state: 'WA',\n              zip: '98101',\n              countyName: 'King',\n              gender: 'F',\n              age: 52,\n              phones: [{\n                phone: 2065557890,\n                carrier: 'T-Mobile',\n                phoneType: 1,\n                workPhone: false,\n                activityStatus: 'Active',\n                contactabilityScore: 'Very High'\n              }],\n              data: {\n                addressType: 'Single Family',\n                incomeLevel: '$150K+',\n                creditRange: '780-850',\n                householdIncome: '$175,000+',\n                homeOwnership: 'Owner',\n                homePrice: 1200000,\n                homeValue: 1350000,\n                age: 52\n              },\n              properties: [{\n                propertyType: 'Single Family Residence',\n                value: 1350000,\n                estimatedValue: 1350000,\n                yearBuilt: 2005,\n                bedrooms: '4',\n                rooms: '9',\n                saleDate: '2018-11-08',\n                saleAmount: 1050000\n              }]\n            }\n          ];\n\n          return {\n            identities: [mockProfiles[index % mockProfiles.length]]\n          };\n        };\n\n        // Parse structured_data, raw_payload, and enhanced_data JSON for each result\n        const parsedResults = (results || []).map((row: any, index: number) => {\n          let enhancedData = row.enhanced_data ? JSON.parse(row.enhanced_data) : null;\n\n          // Inject mock enhanced data for vic@channelautomation.com\n          if (userEmail?.email === 'vic@channelautomation.com' && !enhancedData) {\n            enhancedData = generateMockEnhancedData(index);\n          }\n\n          return {\n            ...row,\n            structured_data: row.structured_data ? JSON.parse(row.structured_data) : null,\n            raw_payload: row.raw_payload ? JSON.parse(row.raw_payload) : null,\n            enhanced_data: enhancedData\n          };\n        });\n\n        // Calculate summary statistics\n        const totalCalls = parsedResults.length;\n        const answeredCalls = parsedResults.filter(call => call.recording_url).length;\n        const avgConfidence = totalCalls > 0\n          ? parsedResults.reduce((sum, call) => sum + 85, 0) / totalCalls // Default confidence\n          : 0;\n\n        const intentDistribution = parsedResults.reduce((acc, call) => {\n          acc[call.intent] = (acc[call.intent] || 0) + 1;\n          return acc;\n        }, {} as Record<string, number>);\n\n        const summaryData = {\n          calls: parsedResults,\n          stats: {\n            totalCalls,\n            answeredCalls,\n            avgConfidence: Math.round(avgConfidence),\n            intentDistribution: Object.entries(intentDistribution).map(([intent, count]) => ({\n              intent,\n              count\n            }))\n          }\n        };\n\n        // Cache the results\n        if (limit <= 100) {\n          // Use effectiveUserId for cache key to scope by workspace owner\n          await cache.cacheIntentSummary(effectiveUserId, summaryData, CACHE_TTL.INTENT_SUMMARY);\n        }\n\n        return jsonResponse(summaryData);\n      }\n\n      // Generate demo data for vic@channelautomation.com\n      if (url.pathname === '/api/generate-demo-data' && request.method === 'POST') {\n        const currentUserId = await getUserFromToken(request, env);\n        if (!currentUserId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        // Use vic's userId for demo data\n        const vicUser = await env.DB.prepare(\n          'SELECT id FROM users WHERE email = ?'\n        ).bind('vic@channelautomation.com').first() as any;\n\n        if (!vicUser) {\n          return jsonResponse({ error: 'Demo account not found' }, 404);\n        }\n\n        const userId = vicUser.id;\n\n        // Get or create webhook for this user\n        let webhook = await env.DB.prepare(\n          'SELECT id FROM webhooks WHERE user_id = ? LIMIT 1'\n        ).bind(userId).first() as any;\n\n        if (!webhook) {\n          const webhookId = generateId();\n          await env.DB.prepare(\n            'INSERT INTO webhooks (id, user_id, webhook_url, name, is_active, created_at, updated_at) VALUES (?, ?, ?, ?, 1, ?, ?)'\n          ).bind(webhookId, userId, `https://api.voice-config.channelautomation.com/webhooks/${webhookId}`, 'Demo Webhook', Date.now(), Date.now()).run();\n          webhook = { id: webhookId };\n        }\n\n        const timestamp = Date.now();\n        const demoCalls = [\n          {\n            id: 'demo_001_' + timestamp,\n            name: 'Sarah Johnson',\n            phone: '+14155551234',\n            intent: 'Scheduling',\n            sentiment: 'Positive',\n            outcome: 'Successful',\n            summary: 'Customer called to schedule a window replacement consultation. Showed strong interest in energy-efficient options.',\n            transcript: 'AI: Thank you for calling EcoView Windows and Doors. This is James. Customer: Hi, this is Sarah Johnson. I am interested in getting some windows replaced. AI: Great! Are you looking for a consultation? Customer: Yes, I am particularly interested in energy-efficient windows. AI: Perfect! Let me schedule that for you.',\n            appointmentDate: new Date(Date.now() + 5 * 86400000).toISOString().split('T')[0],\n            appointmentTime: '2:00 PM',\n            days_ago: 1\n          },\n          {\n            id: 'demo_002_' + timestamp,\n            name: 'Michael Rodriguez',\n            phone: '+15035559876',\n            intent: 'Information',\n            sentiment: 'Neutral',\n            outcome: 'Follow-up Required',\n            summary: 'Customer inquired about pricing for sliding glass doors. Asked about installation timeline and warranty.',\n            transcript: 'AI: Thank you for calling EcoView. This is Alex. Customer: Hi, I am interested in learning about sliding glass doors. Can you tell me about pricing? AI: Our doors range from $2,500 to $8,000. Customer: How long does installation take? AI: Usually one full day. Customer: I need to think about it.',\n            appointmentDate: null,\n            appointmentTime: null,\n            days_ago: 2\n          },\n          {\n            id: 'demo_003_' + timestamp,\n            name: 'Jennifer Chen',\n            phone: '+12065557890',\n            intent: 'Scheduling',\n            sentiment: 'Positive',\n            outcome: 'Successful',\n            summary: 'Existing customer scheduling installation of bay window. Very satisfied with previous service.',\n            transcript: 'AI: Thank you for calling EcoView. This is Maria. Customer: Hi Maria, this is Jennifer Chen. I ordered a bay window last month and want to schedule installation. AI: Of course! When works for you? Customer: Thursday morning around 10 AM. AI: Perfect! You are all set.',\n            appointmentDate: new Date(Date.now() + 3 * 86400000).toISOString().split('T')[0],\n            appointmentTime: '10:00 AM',\n            days_ago: 3\n          },\n          {\n            id: 'demo_004_' + timestamp,\n            name: 'Robert Martinez',\n            phone: '+13105554321',\n            intent: 'Support',\n            sentiment: 'Negative',\n            outcome: 'Follow-up Required',\n            summary: 'Customer reported condensation between window panes. Escalated to warranty department.',\n            transcript: 'AI: EcoView support. This is Tom. Customer: I have condensation between my window panes. AI: That indicates a seal failure. When were they installed? Customer: About 3 years ago. Is this covered? AI: Yes, fully covered. We will replace at no cost.',\n            appointmentDate: null,\n            appointmentTime: null,\n            days_ago: 4\n          },\n          {\n            id: 'demo_005_' + timestamp,\n            name: 'Amanda Foster',\n            phone: '+14085556789',\n            intent: 'Information',\n            sentiment: 'Positive',\n            outcome: 'Successful',\n            summary: 'Customer asking about French doors. Requested free estimate.',\n            transcript: 'AI: Good afternoon! This is Jessica. Customer: Hi! I am looking to replace my patio door with French doors. AI: Yes we offer those! Are you looking for inswing or outswing? Customer: What do you recommend? AI: For patios, outswing is better. Customer: How do I get an estimate? AI: We can schedule a free consultation.',\n            appointmentDate: null,\n            appointmentTime: null,\n            days_ago: 5\n          },\n          {\n            id: 'demo_006_' + timestamp,\n            name: 'David Thompson',\n            phone: '+16195553456',\n            intent: 'Scheduling',\n            sentiment: 'Neutral',\n            outcome: 'Successful',\n            summary: 'Customer rescheduling consultation due to work conflict.',\n            transcript: 'AI: Scheduling department. This is Rachel. Customer: I need to reschedule my Wednesday appointment. AI: No problem! When works better? Customer: Friday afternoon around 3:30? AI: Perfect! You are all set for Friday at 3:30.',\n            appointmentDate: new Date(Date.now() + 7 * 86400000).toISOString().split('T')[0],\n            appointmentTime: '3:30 PM',\n            days_ago: 6\n          },\n          {\n            id: 'demo_007_' + timestamp,\n            name: 'Lisa Anderson',\n            phone: '+14155557777',\n            intent: 'Purchase',\n            sentiment: 'Positive',\n            outcome: 'Successful',\n            summary: 'Customer ready for full house window replacement. Placing deposit.',\n            transcript: 'AI: Good morning! This is Brandon. Customer: I received my quote last week and I am ready to move forward! AI: Fantastic! Let me process your deposit. Customer: Can I pay with credit card? AI: Absolutely. You are making a great investment!',\n            appointmentDate: null,\n            appointmentTime: null,\n            days_ago: 7\n          },\n          {\n            id: 'demo_008_' + timestamp,\n            name: 'James Wilson',\n            phone: '+15035558888',\n            intent: 'Information',\n            sentiment: 'Neutral',\n            outcome: 'Follow-up Required',\n            summary: 'Customer comparing window brands and prices.',\n            transcript: 'AI: Thank you for calling EcoView. This is Sarah. Customer: I am getting quotes from several companies. What brands do you carry? AI: We install Milgard and Pella. Customer: How do your prices compare? AI: We are very competitive. Customer: I am still getting other quotes.',\n            appointmentDate: null,\n            appointmentTime: null,\n            days_ago: 8\n          },\n          {\n            id: 'demo_009_' + timestamp,\n            name: 'Patricia Lee',\n            phone: '+14085559999',\n            intent: 'Support',\n            sentiment: 'Positive',\n            outcome: 'Successful',\n            summary: 'Customer asking about window maintenance. Provided care instructions.',\n            transcript: 'AI: Support team. This is Kevin. Customer: I just had windows installed and want to know how to care for them. AI: For glass, use regular cleaner quarterly. For frames, warm soapy water. Customer: What about tracks? AI: Vacuum monthly. Customer: Perfect, thank you!',\n            appointmentDate: null,\n            appointmentTime: null,\n            days_ago: 9\n          },\n          {\n            id: 'demo_010_' + timestamp,\n            name: 'Christopher Brown',\n            phone: '+16195551111',\n            intent: 'Scheduling',\n            sentiment: 'Positive',\n            outcome: 'Successful',\n            summary: 'New customer wants consultation for windows and doors. Motivated buyer.',\n            transcript: 'AI: Thank you for calling EcoView! This is Michelle. Customer: I just bought a house and want to replace all windows and the front door. AI: Congratulations! How many windows? Customer: About 15 windows and a nice entry door. AI: Perfect! Thursday at 11 AM work? Customer: Perfect!',\n            appointmentDate: new Date(Date.now() + 2 * 86400000).toISOString().split('T')[0],\n            appointmentTime: '11:00 AM',\n            days_ago: 10\n          }\n        ];\n\n        // Insert demo calls\n        for (const call of demoCalls) {\n          const callTimestamp = timestamp - (call.days_ago * 86400000);\n          const rawPayload = JSON.stringify({\n            message: {\n              artifact: {\n                transcript: call.transcript\n              }\n            }\n          });\n\n          await env.DB.prepare(\n            `INSERT INTO webhook_calls (\n              id, webhook_id, user_id, vapi_call_id, phone_number, customer_number,\n              recording_url, ended_reason, summary, intent, sentiment, outcome,\n              analysis_completed, analyzed_at, customer_name, customer_email,\n              appointment_date, appointment_time, appointment_type,\n              structured_data, raw_payload, created_at\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n          ).bind(\n            call.id,\n            webhook.id,\n            userId,\n            call.id,\n            '+18005551234',\n            call.phone,\n            null, // No recording URL for demo data - use actual recording URLs from real calls\n            'customer-ended-call',\n            call.summary,\n            call.intent,\n            call.sentiment,\n            call.outcome,\n            1,\n            Math.floor(callTimestamp / 1000),\n            call.name,\n            null,\n            call.appointmentDate,\n            call.appointmentTime,\n            call.appointmentDate ? 'Consultation' : null,\n            '{}',\n            rawPayload,\n            Math.floor(callTimestamp / 1000)\n          ).run();\n        }\n\n        // Invalidate cache\n        const cache = new VoiceAICache(env.CACHE);\n        await cache.invalidateUserCache(userId);\n\n        return jsonResponse({\n          success: true,\n          message: `Created ${demoCalls.length} demo calls for vic@channelautomation.com`,\n          callsCreated: demoCalls.length\n        });\n      }\n\n      // Get cache statistics\n      if (url.pathname === '/api/cache/stats' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const cache = new VoiceAICache(env.CACHE);\n        const stats = await cache.getCacheStats();\n\n        return jsonResponse({\n          ...stats,\n          ttl: {\n            recordings: CACHE_TTL.RECORDINGS,\n            callDetails: CACHE_TTL.CALL_DETAILS,\n            intentAnalysis: CACHE_TTL.INTENT_ANALYSIS,\n            intentSummary: CACHE_TTL.INTENT_SUMMARY,\n            enhancedData: CACHE_TTL.ENHANCED_DATA\n          }\n        });\n      }\n\n      // ============================================\n      // ADMIN ENDPOINTS\n      // ============================================\n\n      // Helper function to check if user is admin\n      const checkAdminAccess = async (userId: string | null): Promise<boolean> => {\n        if (!userId) return false;\n        \n        // Get user email to check admin status\n        const user = await env.DB.prepare(\n          'SELECT email FROM users WHERE id = ?'\n        ).bind(userId).first() as any;\n        \n        if (!user || !user.email) return false;\n        \n        // Check if email is in admin list (can be configured via env var or hardcoded)\n        // For now, check if email contains 'channelautomation.com' or 'admin'\n        // Hardcoded admin emails for now (can be moved to env var if needed)\n        const adminEmails = 'vic@channelautomation.com'.split(',').map(e => e.trim());\n        return adminEmails.some(adminEmail => \n          user.email.toLowerCase() === adminEmail.toLowerCase() || \n          user.email.toLowerCase().includes(adminEmail.toLowerCase())\n        );\n      };\n\n      // Admin Dashboard Overview\n      if (url.pathname === '/api/admin/dashboard' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const isAdmin = await checkAdminAccess(userId);\n        if (!isAdmin) {\n          return jsonResponse({ error: 'Admin access required' }, 403);\n        }\n\n        // Get basic stats\n        const totalUsers = await env.DB.prepare('SELECT COUNT(*) as count FROM users').first() as any;\n        const totalCalls = await env.DB.prepare('SELECT COUNT(*) as count FROM webhook_calls').first() as any;\n        const totalWebhooks = await env.DB.prepare('SELECT COUNT(*) as count FROM webhooks').first() as any;\n        const activeCalls = await env.DB.prepare('SELECT COUNT(*) as count FROM active_calls').first() as any;\n\n        // Get recent activity\n        const recentUsers = await env.DB.prepare(\n          'SELECT id, email, name, created_at, last_login_at FROM users ORDER BY created_at DESC LIMIT 10'\n        ).all();\n\n        return jsonResponse({\n          success: true,\n          data: {\n            overview: {\n              totalUsers: totalUsers?.count || 0,\n              totalCalls: totalCalls?.count || 0,\n              totalWebhooks: totalWebhooks?.count || 0,\n              activeCalls: activeCalls?.count || 0,\n            },\n            recentUsers: (recentUsers.results || []).map((u: any) => ({\n              id: u.id,\n              email: u.email,\n              name: u.name,\n              created_at: u.created_at,\n              last_login_at: u.last_login_at\n            }))\n          }\n        });\n      }\n\n      // Admin - Get all users\n      if (url.pathname === '/api/admin/users' && request.method === 'GET') {\n        const userId = await getUserFromToken(request, env);\n        if (!userId) {\n          return jsonResponse({ error: 'Unauthorized' }, 401);\n        }\n\n        const isAdmin = await checkAdminAccess(userId);\n        if (!isAdmin) {\n          return jsonResponse({ error: 'Admin access required' }, 403);\n        }\n\n        const users = await env.DB.prepare(\n          'SELECT id, email, name, created_at, last_login_at FROM users ORDER BY created_at DESC'\n        ).all();\n\n        return jsonResponse({\n          success: true,\n          data: users.results || []\n        });\n      }\n\n      // ============================================\n      // PUBLIC WEBHOOK RECEIVER (No Auth Required)\n      // ============================================\n\n      // Receive VAPI webhook data\n      if (url.pathname.startsWith('/webhook/') && request.method === 'POST') {\n        const webhookId = url.pathname.split('/').pop();\n\n        // Validate webhook exists and is active\n        const webhook = await env.DB.prepare(\n          'SELECT id, user_id FROM webhooks WHERE id = ? AND is_active = 1'\n        ).bind(webhookId).first() as any;\n\n        if (!webhook) {\n          return jsonResponse({ error: 'Webhook not found or inactive' }, 404);\n        }\n\n        // Parse VAPI payload\n        let payload: any;\n        try {\n          payload = await request.json();\n        } catch (error) {\n          // Log error\n          await env.DB.prepare(\n            'INSERT INTO webhook_logs (id, webhook_id, status, http_status, error_message, created_at) VALUES (?, ?, ?, ?, ?, ?)'\n          ).bind(\n            generateId(),\n            webhookId,\n            'error',\n            400,\n            'Invalid JSON payload',\n            now()\n          ).run();\n\n          return jsonResponse({ error: 'Invalid JSON payload' }, 400);\n        }\n\n        // Extract fields from VAPI payload\n        const message = payload.message || {};\n        const messageType = message.type || 'end-of-call-report';\n        const call = message.call || {};\n        const customer = call.customer || {};\n        const phoneNumber = call.phoneNumber || {};\n        const artifact = message.artifact || {};\n        const analysis = message.analysis || {};\n\n        const timestamp = now();\n\n        // Log incoming webhook for debugging\n        console.log('[Webhook Debug] Message Type:', messageType);\n        console.log('[Webhook Debug] Call ID:', call.id);\n        console.log('[Webhook Debug] Status:', message.status);\n\n        // Handle status-update events (real-time call status)\n        if (messageType === 'status-update') {\n          const callStatus = message.status; // 'queued', 'ringing', 'in-progress', 'forwarding', 'ended'\n          const vapiCallId = call.id;\n          const customerNumber = customer.number || null;\n\n          // Track active calls (ringing, in-progress, or forwarding)\n          if (callStatus === 'ringing' || callStatus === 'in-progress' || callStatus === 'forwarding') {\n            // Enrich caller data with Twilio Lookup\n            let twilioData: TwilioCallerInfo | null = null;\n            if (customerNumber) {\n              try {\n                const wsSettings = await getWorkspaceSettingsForUser(env, webhook.user_id);\n\n                if (wsSettings?.twilio_account_sid && wsSettings?.twilio_auth_token) {\n                  twilioData = await lookupCallerWithTwilio(\n                    customerNumber,\n                    wsSettings.twilio_account_sid,\n                    wsSettings.twilio_auth_token\n                  );\n                }\n              } catch (error) {\n                console.error('Error enriching caller data:', error);\n              }\n            }\n\n            // Insert or update active call\n            await env.DB.prepare(\n              `INSERT OR REPLACE INTO active_calls\n              (id, user_id, vapi_call_id, customer_number, caller_name, carrier_name, line_type, status, started_at, updated_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n            ).bind(\n              vapiCallId,\n              webhook.user_id,\n              vapiCallId,\n              customerNumber,\n              twilioData?.callerName || null,\n              twilioData?.carrierName || null,\n              twilioData?.lineType || null,\n              callStatus,\n              timestamp,\n              timestamp\n            ).run();\n\n            console.log('[Webhook Debug] Active call inserted/updated:', vapiCallId, 'Status:', callStatus, 'Caller:', twilioData?.callerName || 'Unknown');\n\n            // Invalidate cache\n            const cache = new VoiceAICache(env.CACHE);\n            await cache.invalidateUserCache(webhook.user_id);\n\n            return jsonResponse({ success: true, message: 'Call status updated' });\n\n          } else if (callStatus === 'ended') {\n            // Remove from active calls\n            await env.DB.prepare(\n              'DELETE FROM active_calls WHERE vapi_call_id = ? AND user_id = ?'\n            ).bind(vapiCallId, webhook.user_id).run();\n\n            // Invalidate cache\n            const cache = new VoiceAICache(env.CACHE);\n            await cache.invalidateUserCache(webhook.user_id);\n\n            return jsonResponse({ success: true, message: 'Call ended, removed from active calls' });\n          }\n\n          return jsonResponse({ success: true, message: 'Status update received' });\n        }\n\n        // Handle end-of-call-report (existing logic)\n        const callId = generateId();\n\n        // Enrich caller data with Twilio Lookup (if configured)\n        let twilioData: TwilioCallerInfo | null = null;\n        const customerNumber = customer.number || null;\n\n        if (customerNumber) {\n          try {\n            const wsSettings = await getWorkspaceSettingsForUser(env, webhook.user_id);\n\n            if (wsSettings?.twilio_account_sid && wsSettings?.twilio_auth_token) {\n              twilioData = await lookupCallerWithTwilio(\n                customerNumber,\n                wsSettings.twilio_account_sid,\n                wsSettings.twilio_auth_token\n              );\n            }\n          } catch (error) {\n            console.error('Error enriching caller data with Twilio:', error);\n          }\n        }\n\n        // Calculate duration - check multiple locations in payload\n        let durationSeconds: number | null = null;\n        \n        // First, try to use durationSeconds directly from message\n        if (message.durationSeconds) {\n          durationSeconds = Math.floor(message.durationSeconds);\n        }\n        // Fallback: try message.startedAt and message.endedAt (actual payload structure)\n        else if (message.startedAt && message.endedAt) {\n          try {\n            const startTime = new Date(message.startedAt).getTime();\n            const endTime = new Date(message.endedAt).getTime();\n            durationSeconds = Math.floor((endTime - startTime) / 1000); // Convert to seconds\n          } catch (error) {\n            console.error('Error calculating call duration from message timestamps:', error);\n          }\n        }\n        // Last fallback: try call.startedAt and call.endedAt (older structure)\n        else if (call.startedAt && call.endedAt) {\n          try {\n            const startTime = new Date(call.startedAt).getTime();\n            const endTime = new Date(call.endedAt).getTime();\n            durationSeconds = Math.floor((endTime - startTime) / 1000); // Convert to seconds\n          } catch (error) {\n            console.error('Error calculating call duration from call timestamps:', error);\n          }\n        }\n\n        // Store call data\n        try {\n          await env.DB.prepare(\n            `INSERT INTO webhook_calls (\n              id, webhook_id, user_id, vapi_call_id, phone_number, customer_number,\n              recording_url, ended_reason, summary, structured_data, raw_payload, created_at,\n              caller_name, caller_type, carrier_name, line_type, duration_seconds\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n          ).bind(\n            callId,\n            webhookId,\n            webhook.user_id,\n            call.id || null,\n            phoneNumber.number || null,  // AI agent's phone number\n            customer.number || null,      // Customer's phone number\n            message.recordingUrl || artifact.recordingUrl || null,\n            message.endedReason || call.endedReason || 'unknown',\n            analysis.summary || message.summary || '',\n            JSON.stringify(analysis.structuredData || {}),\n            JSON.stringify(payload),\n            timestamp,\n            twilioData?.callerName || null,\n            twilioData?.callerType || null,\n            twilioData?.carrierName || null,\n            twilioData?.lineType || null,\n            durationSeconds\n          ).run();\n\n          // Log success\n          await env.DB.prepare(\n            'INSERT INTO webhook_logs (id, webhook_id, status, http_status, payload_size, created_at) VALUES (?, ?, ?, ?, ?, ?)'\n          ).bind(\n            generateId(),\n            webhookId,\n            'success',\n            200,\n            JSON.stringify(payload).length,\n            timestamp\n          ).run();\n\n          // Invalidate user cache for new data\n          const cache = new VoiceAICache(env.CACHE);\n          await cache.invalidateUserCache(webhook.user_id);\n\n          // Trigger OpenAI analysis and addons in the background (don't wait for them)\n          ctx.waitUntil(\n            (async () => {\n              try {\n                // First, extract appointment data from VAPI's structured data\n                const structuredData = analysis.structuredData || {};\n                let vapiAppointmentDate = structuredData.appointmentDate || structuredData.appointment_date || null;\n                let vapiAppointmentTime = structuredData.appointmentTime || structuredData.appointment_time || null;\n                let vapiAppointmentType = structuredData.appointmentType || structuredData.appointment_type || null;\n                let vapiCustomerName = structuredData.customerName || structuredData.customer_name || null;\n                let vapiCustomerEmail = structuredData.customerEmail || structuredData.customer_email || null;\n\n                // Get workspace OpenAI API key\n                const wsSettings = await getWorkspaceSettingsForUser(env, webhook.user_id);\n\n                if (wsSettings?.openai_api_key) {\n                  const transcript = artifact.transcript || '';\n                  const summary = analysis.summary || message.summary || '';\n\n                  // Analyze with OpenAI\n                  const analysisResult = await analyzeCallWithOpenAI(\n                    summary,\n                    transcript,\n                    wsSettings.openai_api_key\n                  );\n\n                  if (analysisResult) {\n                    // Extract and store keywords from transcript with sentiment\n                    if (transcript) {\n                      const keywords = extractKeywords(transcript);\n                      await storeKeywords(keywords, webhook.user_id, analysisResult.sentiment, env.DB);\n                    }\n                    // Prioritize VAPI structured data over OpenAI analysis for appointments\n                    const finalAppointmentDate = vapiAppointmentDate || analysisResult.appointment_date;\n                    const finalAppointmentTime = vapiAppointmentTime || analysisResult.appointment_time;\n                    const finalAppointmentType = vapiAppointmentType || analysisResult.appointment_type;\n                    const finalCustomerName = vapiCustomerName || analysisResult.customer_name;\n                    const finalCustomerEmail = vapiCustomerEmail || analysisResult.customer_email;\n\n                    // Calculate appointment_datetime if both date and time are present\n                    let appointmentDatetime: number | null = null;\n                    if (finalAppointmentDate && finalAppointmentTime) {\n                      try {\n                        const dateTimeStr = `${finalAppointmentDate} ${finalAppointmentTime}`;\n                        appointmentDatetime = Math.floor(new Date(dateTimeStr).getTime() / 1000);\n                      } catch (e) {\n                        console.error('Error parsing appointment datetime:', e);\n                      }\n                    }\n\n                    // Update call with analysis results\n                    await env.DB.prepare(\n                      `UPDATE webhook_calls\n                       SET intent = ?, sentiment = ?, outcome = ?,\n                           customer_name = ?, customer_email = ?,\n                           appointment_date = ?, appointment_time = ?, appointment_datetime = ?,\n                           appointment_type = ?, appointment_notes = ?,\n                           analysis_completed = 1, analyzed_at = ?\n                       WHERE id = ?`\n                    ).bind(\n                      analysisResult.intent,\n                      analysisResult.sentiment,\n                      analysisResult.outcome,\n                      finalCustomerName,\n                      finalCustomerEmail,\n                      finalAppointmentDate,\n                      finalAppointmentTime,\n                      appointmentDatetime,\n                      finalAppointmentType,\n                      analysisResult.appointment_notes,\n                      now(),\n                      callId\n                    ).run();\n\n                    // Invalidate cache for this specific call since analysis is now complete\n                    const cache = new VoiceAICache(env.CACHE);\n                    await cache.invalidateCallCache(webhook.user_id, callId);\n\n                    // Trigger Scheduling Webhook if appointment was booked\n                    if (analysisResult.intent === 'Scheduling' && finalAppointmentDate && finalAppointmentTime) {\n                      await triggerSchedulingWebhook(env, webhook.user_id, callId);\n                    }\n                  }\n                } else if (vapiAppointmentDate && vapiAppointmentTime) {\n                  // No OpenAI API key, but we have VAPI appointment data\n                  let appointmentDatetime: number | null = null;\n                  try {\n                    const dateTimeStr = `${vapiAppointmentDate} ${vapiAppointmentTime}`;\n                    appointmentDatetime = Math.floor(new Date(dateTimeStr).getTime() / 1000);\n                  } catch (e) {\n                    console.error('Error parsing appointment datetime:', e);\n                  }\n\n                  // Update call with VAPI appointment data only\n                  await env.DB.prepare(\n                    `UPDATE webhook_calls\n                     SET customer_name = ?, customer_email = ?,\n                         appointment_date = ?, appointment_time = ?, appointment_datetime = ?,\n                         appointment_type = ?,\n                         analysis_completed = 1, analyzed_at = ?\n                     WHERE id = ?`\n                  ).bind(\n                    vapiCustomerName,\n                    vapiCustomerEmail,\n                    vapiAppointmentDate,\n                    vapiAppointmentTime,\n                    appointmentDatetime,\n                    vapiAppointmentType,\n                    now(),\n                    callId\n                  ).run();\n\n                  // Invalidate cache\n                  const cache = new VoiceAICache(env.CACHE);\n                  await cache.invalidateCallCache(webhook.user_id, callId);\n\n                  // Trigger Scheduling Webhook\n                  await triggerSchedulingWebhook(env, webhook.user_id, callId);\n                }\n\n                // Process addons (Enhanced Data, etc.)\n                await processAddonsForCall(\n                  env,\n                  webhook.user_id,\n                  callId,\n                  customer.number\n                );\n              } catch (error) {\n                console.error('Background processing error:', error);\n              }\n            })()\n          );\n\n          return jsonResponse({\n            received: true,\n            call_id: callId\n          });\n\n        } catch (error: any) {\n          // Log error\n          await env.DB.prepare(\n            'INSERT INTO webhook_logs (id, webhook_id, status, http_status, error_message, created_at) VALUES (?, ?, ?, ?, ?, ?)'\n          ).bind(\n            generateId(),\n            webhookId,\n            'error',\n            500,\n            error.message || 'Database error',\n            timestamp\n          ).run();\n\n          return jsonResponse({ error: 'Failed to store call data' }, 500);\n        }\n      }\n\n      // Default 404\n      return jsonResponse({ error: 'Not found' }, 404);\n\n    } catch (error: any) {\n      console.error('Worker error:', error);\n      return jsonResponse({ error: error.message || 'Internal server error' }, 500);\n    }\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/benjiemalinao/Documents/WORKING PROTOTYPE/Voice AI Performance & Config Dashboard/workers/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/benjiemalinao/.nvm/versions/node/v22.12.0/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/benjiemalinao/.nvm/versions/node/v22.12.0/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/benjiemalinao/Documents/WORKING PROTOTYPE/Voice AI Performance & Config Dashboard/workers/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/benjiemalinao/Documents/WORKING PROTOTYPE/Voice AI Performance & Config Dashboard/.wrangler/tmp/bundle-B2uX3S/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/benjiemalinao/.nvm/versions/node/v22.12.0/lib/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/benjiemalinao/Documents/WORKING PROTOTYPE/Voice AI Performance & Config Dashboard/.wrangler/tmp/bundle-B2uX3S/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/benjiemalinao/Documents/WORKING PROTOTYPE/Voice AI Performance & Config Dashboard/.wrangler/tmp/bundle-B2uX3S/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["now", "wsSettings", "assistants", "customerNumber", "twilioData", "cache"]
}
